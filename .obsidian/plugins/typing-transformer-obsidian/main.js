/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i = 0; i < 64; i++)
    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
  return (base64) => {
    var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
    for (var i2 = 0, j = 0; i2 < n; ) {
      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingTransformer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_commands = require("@codemirror/commands");
var import_view3 = require("@codemirror/view");

// wasm-binary:/home/runner/work/typing-transformer-obsidian/typing-transformer-obsidian/liberty-web/charliberty_bg.wasm
var charliberty_bg_exports = {};
__export(charliberty_bg_exports, {
  default: () => charliberty_bg_default
});
var charliberty_bg_default = __toBinary("AGFzbQEAAAABcBBgAn9/AGACf38Bf2ADf39/AX9gA39/fwBgAX8AYAF/AX9gBH9/f38AYAV/f39/fwBgBX9/f39/AX9gAABgBH9/f38Bf2AHf39/f39/fwBgBn9/f39/fwBgB39/f39/f38Bf2ADf35+AX9gA39+fgACGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAAPCAcABBQYBAAsAAAAMAAAAAAAABgAAAQIAAAAAAAAAAgMIAAADBgAAAgAEAAICAQcAAgAAAAAAAQEAAAgNAAABAAEBAAAIBAAABgEHAwADAAABAAADAAAAAgcDAAAABAYBAwoFAQEHAQEBAQQDAQEAAQMABAECAQQCAQAAAgQDAAEFCAEJBQADAAAAAgQBBQQOAQQAAQMBAAQKAAIBAQcAAQAAAQABAAAAAQEBAAMBAwQFBA8ACQkBAQEAAQEAAQIAAQQDBAUBcAFPTwUDAQARBgkBfwFBgIDAAAsHvwEKBm1lbW9yeQIACmZvcm1hdExpbmUAVxFfX3diZ19ibG9ja3NfZnJlZQBoDmJsb2Nrc19zcGVjaWFsAFkPYmxvY2tzX2VtcGhhc2lzAFoOZ2V0QmxvY2tSYW5nZXMAVR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAK4BEV9fd2JpbmRnZW5fbWFsbG9jAH4SX193YmluZGdlbl9yZWFsbG9jAIgBD19fd2JpbmRnZW5fZnJlZQCXAQmBAQEAQQELTp0BigGrAY4BvwG0AX1ncGRta4kBc48BoAFxapMBWwNdvQGcAYYBvQHAAa8BgAG+AXefAZ4Bd5UBlAGhAY0BsAFmZZkBKU61AWyPAXU+tgGjAaQBpgF4pQG3AYwBYkpUvQGRAW+QAY8BeTy4AbkBmgGnAagBK2FHLna7AQry/gTAAYQkAgl/AX4jAEEQayIIJAACfwJAAkACQAJAAkACQCAAQfUBTwRAQQAgAEHN/3tPDQcaIABBC2oiAUF4cSEFQfzNwAAoAgAiCUUNBEEfIQdBACAFayEEIABB9P//B00EQCAFQQYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQcLIAdBAnRB4MrAAGooAgAiAUUEQEEAIQAMAgtBACEAIAVBGSAHQQF2a0EAIAdBH0cbdCEDA0ACQCABKAIEQXhxIgYgBUkNACAGIAVrIgYgBE8NACABIQIgBiIEDQBBACEEIAEhAAwECyABKAIUIgYgACAGIAEgA0EddkEEcWpBEGooAgAiAUcbIAAgBhshACADQQF0IQMgAQ0ACwwBC0H4zcAAKAIAIgJBECAAQQtqQfgDcSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiBkEDdCIAQfDLwABqIgMgAEH4y8AAaigCACIBKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H4zcAAIAJBfiAGd3E2AgALIAEgAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBCABQQhqDAcLIAVBgM7AACgCAE0NAwJAAkAgAUUEQEH8zcAAKAIAIgBFDQYgAGhBAnRB4MrAAGooAgAiAigCBEF4cSAFayEEIAIhAQNAAkAgAigCECIADQAgAigCFCIADQAgASgCGCEHAkACQCABIAEoAgwiAEYEQCABQRRBECABKAIUIgAbaigCACICDQFBACEADAILIAEoAggiAiAANgIMIAAgAjYCCAwBCyABQRRqIAFBEGogABshAwNAIAMhBiACIgBBFGogAEEQaiAAKAIUIgIbIQMgAEEUQRAgAhtqKAIAIgINAAsgBkEANgIACyAHRQ0EIAEgASgCHEECdEHgysAAaiICKAIARwRAIAdBEEEUIAcoAhAgAUYbaiAANgIAIABFDQUMBAsgAiAANgIAIAANA0H8zcAAQfzNwAAoAgBBfiABKAIcd3E2AgAMBAsgACgCBEF4cSAFayICIAQgAiAESSICGyEEIAAgASACGyEBIAAhAgwACwALAkBBAiAAdCIDQQAgA2tyIAEgAHRxaCIGQQN0IgFB8MvAAGoiAyABQfjLwABqKAIAIgAoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQfjNwAAgAkF+IAZ3cTYCAAsgACAFQQNyNgIEIAAgBWoiBiABIAVrIgNBAXI2AgQgACABaiADNgIAQYDOwAAoAgAiBARAIARBeHFB8MvAAGohAUGIzsAAKAIAIQICf0H4zcAAKAIAIgVBASAEQQN2dCIEcUUEQEH4zcAAIAQgBXI2AgAgAQwBCyABKAIICyEEIAEgAjYCCCAEIAI2AgwgAiABNgIMIAIgBDYCCAtBiM7AACAGNgIAQYDOwAAgAzYCACAAQQhqDAgLIAAgBzYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQAgACACNgIUIAIgADYCGAsCQAJAIARBEE8EQCABIAVBA3I2AgQgASAFaiIDIARBAXI2AgQgAyAEaiAENgIAQYDOwAAoAgAiBkUNASAGQXhxQfDLwABqIQBBiM7AACgCACECAn9B+M3AACgCACIFQQEgBkEDdnQiBnFFBEBB+M3AACAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAI2AgggBiACNgIMIAIgADYCDCACIAY2AggMAQsgASAEIAVqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQtBiM7AACADNgIAQYDOwAAgBDYCAAsgAUEIagwGCyAAIAJyRQRAQQAhAkECIAd0IgBBACAAa3IgCXEiAEUNAyAAaEECdEHgysAAaigCACEACyAARQ0BCwNAIAAgAiAAKAIEQXhxIgMgBWsiBiAESSIHGyEJIAAoAhAiAUUEQCAAKAIUIQELIAIgCSADIAVJIgAbIQIgBCAGIAQgBxsgABshBCABIgANAAsLIAJFDQAgBUGAzsAAKAIAIgBNIAQgACAFa09xDQAgAigCGCEHAkACQCACIAIoAgwiAEYEQCACQRRBECACKAIUIgAbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyACQRRqIAJBEGogABshAwNAIAMhBiABIgBBFGogAEEQaiAAKAIUIgEbIQMgAEEUQRAgARtqKAIAIgENAAsgBkEANgIACyAHRQ0CIAIgAigCHEECdEHgysAAaiIBKAIARwRAIAdBEEEUIAcoAhAgAkYbaiAANgIAIABFDQMMAgsgASAANgIAIAANAUH8zcAAQfzNwAAoAgBBfiACKAIcd3E2AgAMAgsCQAJAAkACQAJAIAVBgM7AACgCACIBSwRAIAVBhM7AACgCACIATwRAIAVBr4AEakGAgHxxIgJBEHZAACEAIAhBBGoiAUEANgIIIAFBACACQYCAfHEgAEF/RiICGzYCBCABQQAgAEEQdCACGzYCAEEAIAgoAgQiAUUNCRogCCgCDCEGQZDOwAAgCCgCCCIEQZDOwAAoAgBqIgA2AgBBlM7AAEGUzsAAKAIAIgIgACAAIAJJGzYCAAJAAkBBjM7AACgCACICBEBB4MvAACEAA0AgASAAKAIAIgMgACgCBCIHakYNAiAAKAIIIgANAAsMAgtBnM7AACgCACIAQQAgACABTRtFBEBBnM7AACABNgIAC0GgzsAAQf8fNgIAQezLwAAgBjYCAEHky8AAIAQ2AgBB4MvAACABNgIAQfzLwABB8MvAADYCAEGEzMAAQfjLwAA2AgBB+MvAAEHwy8AANgIAQYzMwABBgMzAADYCAEGAzMAAQfjLwAA2AgBBlMzAAEGIzMAANgIAQYjMwABBgMzAADYCAEGczMAAQZDMwAA2AgBBkMzAAEGIzMAANgIAQaTMwABBmMzAADYCAEGYzMAAQZDMwAA2AgBBrMzAAEGgzMAANgIAQaDMwABBmMzAADYCAEG0zMAAQajMwAA2AgBBqMzAAEGgzMAANgIAQbzMwABBsMzAADYCAEGwzMAAQajMwAA2AgBBuMzAAEGwzMAANgIAQcTMwABBuMzAADYCAEHAzMAAQbjMwAA2AgBBzMzAAEHAzMAANgIAQcjMwABBwMzAADYCAEHUzMAAQcjMwAA2AgBB0MzAAEHIzMAANgIAQdzMwABB0MzAADYCAEHYzMAAQdDMwAA2AgBB5MzAAEHYzMAANgIAQeDMwABB2MzAADYCAEHszMAAQeDMwAA2AgBB6MzAAEHgzMAANgIAQfTMwABB6MzAADYCAEHwzMAAQejMwAA2AgBB/MzAAEHwzMAANgIAQYTNwABB+MzAADYCAEH4zMAAQfDMwAA2AgBBjM3AAEGAzcAANgIAQYDNwABB+MzAADYCAEGUzcAAQYjNwAA2AgBBiM3AAEGAzcAANgIAQZzNwABBkM3AADYCAEGQzcAAQYjNwAA2AgBBpM3AAEGYzcAANgIAQZjNwABBkM3AADYCAEGszcAAQaDNwAA2AgBBoM3AAEGYzcAANgIAQbTNwABBqM3AADYCAEGozcAAQaDNwAA2AgBBvM3AAEGwzcAANgIAQbDNwABBqM3AADYCAEHEzcAAQbjNwAA2AgBBuM3AAEGwzcAANgIAQczNwABBwM3AADYCAEHAzcAAQbjNwAA2AgBB1M3AAEHIzcAANgIAQcjNwABBwM3AADYCAEHczcAAQdDNwAA2AgBB0M3AAEHIzcAANgIAQeTNwABB2M3AADYCAEHYzcAAQdDNwAA2AgBB7M3AAEHgzcAANgIAQeDNwABB2M3AADYCAEH0zcAAQejNwAA2AgBB6M3AAEHgzcAANgIAQYzOwAAgAUEPakF4cSIAQQhrIgI2AgBB8M3AAEHozcAANgIAQYTOwAAgBEEoayIDIAEgAGtqQQhqIgA2AgAgAiAAQQFyNgIEIAEgA2pBKDYCBEGYzsAAQYCAgAE2AgAMCAsgAiADSSABIAJNcg0AIAAoAgwiA0EBcQ0AIANBAXYgBkYNAwtBnM7AAEGczsAAKAIAIgAgASAAIAFJGzYCACABIARqIQNB4MvAACEAAkACQANAIAMgACgCACIHRwRAIAAoAggiAA0BDAILCyAAKAIMIgNBAXENACADQQF2IAZGDQELQeDLwAAhAANAAkAgAiAAKAIAIgNPBEAgAiADIAAoAgRqIgdJDQELIAAoAgghAAwBCwtBjM7AACABQQ9qQXhxIgBBCGsiAzYCAEGEzsAAIARBKGsiCSABIABrakEIaiIANgIAIAMgAEEBcjYCBCABIAlqQSg2AgRBmM7AAEGAgIABNgIAIAIgB0Ega0F4cUEIayIAIAAgAkEQakkbIgNBGzYCBEHgy8AAKQIAIQogA0EQakHoy8AAKQIANwIAIAMgCjcCCEHsy8AAIAY2AgBB5MvAACAENgIAQeDLwAAgATYCAEHoy8AAIANBCGo2AgAgA0EcaiEAA0AgAEEHNgIAIABBBGoiACAHSQ0ACyACIANGDQcgAyADKAIEQX5xNgIEIAIgAyACayIAQQFyNgIEIAMgADYCACAAQYACTwRAIAIgABBBDAgLIABB+AFxQfDLwABqIQECf0H4zcAAKAIAIgNBASAAQQN2dCIAcUUEQEH4zcAAIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCAwHCyAAIAE2AgAgACAAKAIEIARqNgIEIAFBD2pBeHFBCGsiAiAFQQNyNgIEIAdBD2pBeHFBCGsiBCACIAVqIgBrIQUgBEGMzsAAKAIARg0DIARBiM7AACgCAEYNBCAEKAIEIgFBA3FBAUYEQCAEIAFBeHEiARA6IAEgBWohBSABIARqIgQoAgQhAQsgBCABQX5xNgIEIAAgBUEBcjYCBCAAIAVqIAU2AgAgBUGAAk8EQCAAIAUQQQwGCyAFQfgBcUHwy8AAaiEBAn9B+M3AACgCACIDQQEgBUEDdnQiBHFFBEBB+M3AACADIARyNgIAIAEMAQsgASgCCAshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggMBQtBhM7AACAAIAVrIgE2AgBBjM7AAEGMzsAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGoMCAtBiM7AACgCACEAAkAgASAFayICQQ9NBEBBiM7AAEEANgIAQYDOwABBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQtBgM7AACACNgIAQYjOwAAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIECyAAQQhqDAcLIAAgBCAHajYCBEGMzsAAQYzOwAAoAgAiAEEPakF4cSIBQQhrIgI2AgBBhM7AAEGEzsAAKAIAIARqIgMgACABa2pBCGoiATYCACACIAFBAXI2AgQgACADakEoNgIEQZjOwABBgICAATYCAAwDC0GMzsAAIAA2AgBBhM7AAEGEzsAAKAIAIAVqIgE2AgAgACABQQFyNgIEDAELQYjOwAAgADYCAEGAzsAAQYDOwAAoAgAgBWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACyACQQhqDAMLQQBBhM7AACgCACIAIAVNDQIaQYTOwAAgACAFayIBNgIAQYzOwABBjM7AACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqDAILIAAgBzYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQCAEQRBPBEAgAiAFQQNyNgIEIAIgBWoiACAEQQFyNgIEIAAgBGogBDYCACAEQYACTwRAIAAgBBBBDAILIARB+AFxQfDLwABqIQECf0H4zcAAKAIAIgNBASAEQQN2dCIEcUUEQEH4zcAAIAMgBHI2AgAgAQwBCyABKAIICyEDIAEgADYCCCADIAA2AgwgACABNgIMIAAgAzYCCAwBCyACIAQgBWoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAsgAkEIagsgCEEQaiQAC4goAQ1/IwBBwAJrIgYkAEGpysAALQAAGgJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkBB3ABBBBCiASIEBEAgBEGCBDsBWCAEQgA3AlAgBCACNgJMIAQgATYCSCAEQgQ3AkAgBEIANwI4IARCgICAgMAANwIwIARCBDcCKCAEQgA3AiAgBEKAgICAEDcCGCAEQgE3AhAgBEIANwIIIARCgICAgMAANwIAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMtAABBAWsOGwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhwLIAJFDSUgAS0AAEEgRw0lIARBATYCUAwnCyAGQQhqIAQQBiAGKAIMIQQgBigCCAwbCyAGQRBqIAQQDCAGKAIUIQQgBigCEAwaCyAGQRhqIAQQGSAGKAIcIQQgBigCGAwZCyAGQSBqIAQQESAGKAIkIQQgBigCIAwYCyAGQShqIAQQFSAGKAIsIQQgBigCKAwXCyAGQTBqIAQQGyAGKAI0IQQgBigCMAwWCyAGQThqIAQQDiAGKAI8IQQgBigCOAwVCyAGQUBrIAQQICAGKAJEIQQgBigCQAwUCyAGQcgAaiAEEBogBigCTCEEIAYoAkgMEwsgBkHQAGogBBAwIAYoAlQhBCAGKAJQDBILIAZB2ABqIAQQCyAGKAJcIQQgBigCWAwRCyACQQJJDQ4gAS8AAEHcyABHDQ4gBEECNgJQDBsLIAZB6ABqIAQQFiAGKAJsIQQgBigCaAwPCyAGQfAAaiAEECQgBigCdCEEIAYoAnAMDgsgBkH4AGogBBAXIAYoAnwhBCAGKAJ4DA0LIAZBgAFqIAQQEiAGKAKEASEEIAYoAoABDAwLIAZBiAFqIAQQLSAGKAKMASEEIAYoAogBDAsLIAZBkAFqIAQQDyAGKAKUASEEIAYoApABDAoLIAZBmAFqIAQQByAGKAKcASEEIAYoApgBDAkLIAZBoAFqIAQQCiAGKAKkASEEIAYoAqABDAgLIAZBqAFqIAQQGCAGKAKsASEEIAYoAqgBDAcLIAZBsAFqIAQQCCAGKAK0ASEEIAYoArABDAYLIAZBuAFqIAQQKCAGKAK8ASEEIAYoArgBDAULIAZBwAFqIAQQDSAGKALEASEEIAYoAsABDAQLIAZByAFqIAQQNyAGKALMASEEIAYoAsgBDAMLIARBmIPAABBMIAQoAgQiA0IANwIEIANBADoAACAEQQE2AgggBCgCVEUEQCAEKAIgIAQoAhRqIQULIAQoAkwhCiAEKAJIIQkgBCgCUCIOBEAgBCAONgJQIAQgCjYCTCAEIAk2AkhBASEIDAoLIARBJGoQeiAGQfABaiAEEDcgBigC9AEhBCAGKALwAQ0EIAQoAkQiAwRAIAQgA0EBazYCRAsgBCgCUCEHIAQoAkwhCyAEKAJIIQ8gBCgCCCEDIARBJGoQeiAGQegBaiAEEDcgBigC7AEhBCAGKALoAUUEQCAEKAJEIgMNBgwHCyAEQSRqEEMgBCAHNgJQIAQgCzYCTCAEIA82AkggBCgCCCADSQ0IIAQgAzYCCAwICyAGQeAAaiAEEDEgBigCZCEEIAYoAmAMAQsgBiAEEB8gBigCBCEEIAYoAgALDQgMCgtBBEHcABC6AQALIARBJGoQQwwDC0EADAELQQELIQcDQCAHRQRAIAQgA0EBayIINgJEQQEhBwwBCyAEKAIsIQ0gBCgCUCEDIAQoAkwhCyAEKAJIIQ8gBCgCCCEHIAQoAjwgCEYEQCAEQTxqQfCRwAAQUAsgBCgCQCAIQQJ0aiANNgIAIAQgCEEBajYCRCAGQeABaiAEEDcgBigC5AEhBAJAAkAgBigC4AENACAEKAJEIgMNAQNAIAQoAiwhDSAEKAJQIQMgBCgCTCELIAQoAkghDyAEKAIIIQcgBCgCPEUEQCAEQTxqQfCRwAAQUAsgBCgCQCANNgIAIARBATYCRCAGQdgBaiAEEDcgBigC3AEhBCAGKALYAQ0BIAQoAkQiA0UNAAsMAQsgBEEkahBDIAQgAzYCUCAEIAs2AkwgBCAPNgJIIAQoAgggB0kNAiAEIAc2AggMAgtBACEHDAALAAsgBkHQAWogBBAfIAYoAtQBIQQgBigC0AEiCEUNASAEIA42AlAgBCAKNgJMIAQgCTYCSCAEKAIIRQ0BCyAEQQE2AggLIAQtAFghAwJAAkAgCEUEQCADQf8BcUEBRg0BDAQLIANB/wFxQQFHDQEMAgsgBCAFEFMgBC0AWCEDDAILIAQgBRBTIAQtAFhBAkcNACAELQBZRQ0AIARBADYCCAsCQCAEKAIUIgNBAkkNACAEKAIQIQUCQCADQRVPBEAgBSADIAZBvwJqEF4MAQsgBSADEFgLIAQoAhQiCkECSQ0AIApBAWshBSAEKAIQIQlBACEDA0AgAyAJaiIIQQFqLQAAIAgtAABGBEAgA0EBaiEHAkAgA0ECaiIFIApPDQAgCiADa0EBcQRAIAhBAmotAAAiDiAILQAARwRAIAhBAWogDjoAACAFIQcLIANBA2ohBQsgCkEDayADRg0AIAogBWshCCAFIAlqIQMDQCADLQAAIgUgByAJaiIKQQFrLQAARwRAIAogBToAACAHQQFqIQcLIANBAWotAAAiBSAHIAlqIgpBAWstAABHBEAgCiAFOgAAIAdBAWohBwsgA0ECaiEDIAhBAmsiCA0ACwsgBCAHNgIUDAILIAUgA0EBaiIDRw0ACwsCQCAEKAIgIgNBAkkNACAEKAIcIQUCQCADQRVPBEAgBSADIAZBvwJqEF4MAQsgBSADEFgLIAQoAiAiCkECSQ0AIApBAWshBSAEKAIcIQlBACEDA0AgAyAJaiIIQQFqLQAAIAgtAABGBEAgA0EBaiEHAkAgA0ECaiIFIApPDQAgCiADa0EBcQRAIAhBAmotAAAiDiAILQAARwRAIAhBAWogDjoAACAFIQcLIANBA2ohBQsgCkEDayADRg0AIAogBWshCCAFIAlqIQMDQCADLQAAIgUgByAJaiIKQQFrLQAARwRAIAogBToAACAHQQFqIQcLIANBAWotAAAiBSAHIAlqIgpBAWstAABHBEAgCiAFOgAAIAdBAWohBwsgA0ECaiEDIAhBAmsiCA0ACwsgBCAHNgIgDAILIAUgA0EBaiIDRw0ACwtBACEHAkACQAJAIAQoAhQiA0EASA0AIAQoAhAhCgJAIANFBEBBASEFDAELQanKwAAtAAAaQQEhByADQQEQogEiBUUNAQsgBSAKIAMQJSEKQQAhBSAEKAIgIgdBAEgNASAEKAIcIQkCQCAHRQRAQQEhCAwBC0GpysAALQAAGkEBIQUgB0EBEKIBIghFDQILIAggCSAHECUhBSAGIAc2ApwCIAYgBTYCmAIgBiAHNgKUAiAGIAM2ApACIAYgCjYCjAIgBiADNgKIAiAGQbACaiEDAkACQCAEKAJUIgVFDQACQCACIAVNBEAgAiAFRw0BDAILIAEgBWosAABBv39KDQELIANBADYCAAwBCyADIAU2AgggAyACNgIEIAMgATYCAAsgBigCsAJFDQIgBkGoAmogBkG4AmooAgA2AgAgBiAGKQKwAjcDoAIgACEHIAZBiAJqIQ8jAEEQayIOJAACQAJAAkACQCAGQaACaiIFKAIIIgogBSgCBCIITQRAIAUoAgAhAEEAIQsCQCAFKAIEIgFFDQAgBSgCACIJIAFqIQIgBSgCCCENA0AgAiAJRg0BIAJBAWsiASwAACIDQQBIBEAgA0E/cQJ/IAJBAmsiAS0AACIDwCIMQUBOBEAgA0EfcQwBCyAMQT9xAn8gAkEDayIBLQAAIgPAIgxBQE4EQCADQQ9xDAELIAxBP3EgAkEEayIBLQAAQQdxQQZ0cgtBBnRyC0EGdHIhAwsgDSABIgIgCWsiDE0NAAsgA0EKRwR/A0AgASAJRg0CIAFBAWsiAywAACICQQBIBEAgAkE/cQJ/IAFBAmsiAy0AACICwCINQUBOBEAgAkEfcQwBCyANQT9xAn8gAUEDayIDLQAAIgLAIg1BQE4EQCACQQ9xDAELIA1BP3EgAUEEayIDLQAAQQdxQQZ0cgtBBnRyC0EGdHIhAgsgAyEBIAJBCkcNAAsgAyAJawUgDAtBAWohCwsgCyIJIAUoAgQiCwR/AkAgBSgCCCIQIAtBAWtGDQAgBSgCACICIAtqIQ1BACEDA0AgAyEBIAIiAyANRg0BAn8gAywAACICQQBOBEAgAkH/AXEhBSADQQFqDAELIAMtAAFBP3EhDCACQR9xIQUgAkFfTQRAIAVBBnQgDHIhBSADQQJqDAELIAMtAAJBP3EgDEEGdHIhDCACQXBJBEAgDCAFQQx0ciEFIANBA2oMAQsgBUESdEGAgPAAcSADLQADQT9xIAxBBnRyciEFIANBBGoLIgIgA2sgAWohAyABIBBJDQALIAVBCkcEQANAIAMhASACIgMgDUYNAgJ/IAMsAAAiAkEATgRAIAJB/wFxIQUgA0EBagwBCyADLQABQT9xIQwgAkEfcSEFIAJBX00EQCAFQQZ0IAxyIQUgA0ECagwBCyADLQACQT9xIAxBBnRyIQwgAkFwSQRAIAwgBUEMdHIhBSADQQNqDAELIAVBEnRBgIDwAHEgAy0AA0E/cSAMQQZ0cnIhBSADQQRqCyICIAEgA2tqIQMgBUEKRw0ACwsgAUEBaiELCyALBUEACyIBSw0DIAlFDQIgCCAJSw0BIAggCUcNAwwCC0G4i8AAQRZB0IvAABCEAQALIAAgCWosAABBv39MDQELAkAgAUUNACABIAhPBEAgASAIRw0CDAELIAAgAWosAABBv39MDQELIA5BBGohCyAAIAlqIQ1BACEDIwBBEGsiAiQAAkACQCABIAlrIgFBAEgNAAJAIAFFBEBBASEFDAELQanKwAAtAAAaQQEhAyABQQEQogEiBUUNAQsgAkEEaiAFIA0gARAlIgMgAUENQZClwAAQLCALIAIoAggiBSACKAIMQQpBk6XAABAsIAIoAgQiCQRAIAUgCRCpAQsgAQRAIAMgARCpAQsgAkEQaiQADAELIAMgAUHIo8AAEJIBAAsgACAKaiEBAkACQCAKRSAIIApNckUEQCABLAAAQb9/Sg0BIAAgCEEAIApB4IvAABCbAQALIAoNAEEBIQhBASEDDAELQYGAxAAhBSAKIQJBASEDQQEhCANAAkACQAJAAkAgBUGAgMQAaw4CAQADCyAAIAFGDQAgACwAACIFQQBOBEAgAEEBaiEAIAVB/wFxIQUMAwsgAC0AAUE/cSELIAVBH3EhCSAFQV9NBEAgCUEGdCALciEFIABBAmohAAwDCyAALQACQT9xIAtBBnRyIQsgBUFwTw0BIAsgCUEMdHIhBSAAQQNqIQAMAgtB8IvAAEEoQZiMwAAQewALIAlBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIhBSAAQQRqIQALAkACfwJ/AkACQAJAAkAgBUEKaw4EAQAAAgALIAVBgAFPDQJBfwwDC0EBIQggA0EBaiEDIAJBAWsMAwsCQAJAIAAgAUYEQEGAgMQAIQUgASEADAELAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhCyAFQR9xIQkgBUFfTQRAIAlBBnQgC3IhBSAAQQJqDAELIAAtAAJBP3EgC0EGdHIhCyAFQXBJBEAgCyAJQQx0ciEFIABBA2oMAQsgCUESdEGAgPAAcSAALQADQT9xIAtBBnRyciEFIABBBGoLIQAgBUEKRg0BCyAIQQFqIQggAkEBayECDAQLQQEhCCADQQFqIQMgAkEBRg0FIAJBAmsMAgtBfiAFQYAQSQ0AGkF9QXwgBUGAgARJGwshBSAIQQFqIQggAiAFagshAkGBgMQAIQULIAINAAsLIAdBgICAgHg2AkQgByAINgIUIAcgAzYCECAHQQA2AgwgByAKNgIEIAdBADYCACAHIA4pAgQ3AiAgB0GAgICAeDYCUCAHIA8pAgA3AiwgB0E8aiAPQRBqKQIANwIAIAdBNGogD0EIaikCADcCACAHQShqIA5BDGooAgA2AgAgDkEQaiQADAELIAAgCCAJIAFBqIvAABCbAQALIAQoAgAiAARAIAQoAgQgAEEMbBCpAQsMBQsgByADQfShwAAQkgEACyAFIAdB9KHAABCSAQALQcCEwAAQrQEACyADQf8BcUECRw0AIAQtAFlFDQAgBCgCCCIDRQ0CIAQoAgQiBS0AAA0DIAUgAzYCBCAEKAJQIQcgBCgCCCIDIAQoAgBGBEAgBEG4g8AAEEwLIAQoAgQgA0EMbGoiBSAHNgIIIAVBADYCBCAFQYE2OwEAIAQgA0EBajYCCAsgBkGAAmoiBSAEQQhqKAIAIgc2AgAgBiAEKQIANwP4AUGpysAALQAAGkEUQQQQogEiA0UNAyADIAYpA/gBNwIIIANCgYCAgBA3AgAgACAHNgIUIABBADYCECAAIAI2AgwgACABNgIIIAAgAzYCBCAAQQI2AgAgA0EQaiAFKAIANgIACyAEKAIMIgAEQCAEKAIQIAAQqQELIAQoAhgiAARAIAQoAhwgABCpAQsgBCgCJCIABEAgBCgCKCAAQRRsEKkBCyAEKAIwIgAEQCAEKAI0IABBBHQQqQELIAQoAjwiAARAIAQoAkAgAEECdBCpAQsgBEHcABCpASAGQcACaiQADwtBAEEAQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC0EEQRQQugEAC8gdAgZ/A34jAEGwBWsiAiQAIAIgACgCECIEIAAoAhgiBSAEIAVLGyAEIAAoAgwiBxs2AqQFIAJBATYCPCACQeSIwAA2AjggAkIBNwJEIAJCgICAgDAiCSACQaQFaq0iCIQ3A/AEIAIgAkHwBGo2AkAgAkGYBGogAkE4ahA2IAIoAqAEIQYgAigCmAQiAwRAIAIoApwEIAMQqQELQQAhAyACQQA2AkAgAkKAgICAEDcCOCAGBEADQCACKAI4IANGBEAgAkE4akGEjcAAEFILIAIoAjwgA2pBIDoAACACIANBAWoiAzYCQCADIAZHDQALCyACQRhqIAJBQGsoAgA2AgAgAiACKQI4NwMQAkACQCAAKAJEQYCAgIB4RwRAIAIgAEHEAGo2AqQFIAJBAjYCPCACQfSFwAA2AjggAkIBNwJEIAIgCEKAgICAwACENwPwBCACIAJB8ARqNgJAIAJBmARqIAJBOGoQNiACKAKYBCIDQYCAgIB4Rw0BCyACQQA2AiggAkKAgICAEDcCIAwBCyACIAIpApwENwIkIAIgAzYCIAsCQAJAIAcEQCAAKAJQQYCAgIB4Rw0BCyACIAQ2AogFIAIgACgCFCIDNgKMBSACIAM2ApQFIAIgBDYCkAUgAkGYBWoiAyAAECMgAkGkBWogABAvIAIgCEKAgICAECIIhDcDyAQgAiAIIAOthDcDwAQgAiAIIABBIGqthDcDuAQgAiAJIAJBlAVqrYQ3A7AEIAIgCSACQYgFaq2ENwOoBCACIAggAkEgaq2ENwOgBCACIAggAkEQaq2ENwOYBCACQdcAaiACQTZqIgAtAAA6AAAgAkEDOgBUIAJBADYCUCACQiA3AkggAkECNgJAIAJBAjYCOCACIAIvADQ7AFUgAkEDOgCUASACQQA2ApABIAJCoICAgCA3AogBIAJBAjYCgAEgAkECNgJ4IAJBAzoAdCACQQA2AnAgAkKggICAEDcCaCACQQI2AmAgAkECNgJYIAJBlwFqIAJBLmoiAy0AADoAACACQdcBaiAALQAAOgAAIAJBAjYCmAEgAkECNgKgASACQQA2ArABIAJBAjYCuAEgAkECNgLAASACQQA2AtABIAJCoICAgDA3AqgBIAJCIDcCyAEgAkEDOgDUASACQQM6ALQBIAIgAi8ALDsAlQEgAiACLwA0OwDVASACQfcBaiADLQAAOgAAIAJBAzoA9AEgAkEANgLwASACQqCAgIAgNwLoASACQQI2AuABIAJBAjYC2AEgAkEDOgC0AiACQQM6AJQCIAJCIDcCqAIgAkKggICAwAA3AogCIAJBADYCsAIgAkECNgKgAiACQQI2ApgCIAJBADYCkAIgAkECNgKAAiACQQI2AvgBIAIgAi8ALDsA9QEgAkG3AmogAC0AADoAACACIAIvADQ7ALUCIAJBAzoA9AIgAkEANgLwAiACQiA3AugCIAJBAjYC4AIgAkECNgLYAiACQQM6ANQCIAJBADYC0AIgAkKggICA0AA3AsgCIAJBAjYCwAIgAkECNgK4AiACQfcCaiAALQAAOgAAIAIgAi8ANDsA9QIgAkEDOgCUAyACQQA2ApADIAJCIDcCiAMgAkECNgKAAyACQQI2AvgCIAJBlwNqIAAtAAA6AAAgAiACLwA0OwCVAyACQQM6ALQDIAJBADYCsAMgAkKggICA4AA3AqgDIAJBAjYCoAMgAkECNgKYAyACQQw2AoQFIAJBDDYC9AQgAkGEiMAANgLwBCACIAJBOGo2AoAFIAJBBzYC/AQgAiACQZgEajYC+AQgAkEEaiACQfAEahA2IAIoAqQFIgAEQCACKAKoBSAAEKkBCyACKAKYBSIARQ0BIAIoApwFIAAQqQEMAQsgAiAAKAIcNgIwIAIgBTYCLCACIABB0ABqNgI0IABBIGohAyAFIARrQQFNBEAgAjUCGCEKIAIgBDYCiAUgAiAAKAIUIgU2AowFIAIgBTYClAUgAiAENgKQBSACQZgFaiIEIAAQIyACQaQFaiAAEC8gAiAKQiCGNwPgBCACIAhCgICAgBAiCIQ3A9gEIAIgCCAErYQ3A9AEIAIgAkE0aq1CgICAgMAAhDcDyAQgAiAJIAJBLGqthDcDwAQgAiAIIAOthDcDuAQgAiAJIAJBlAVqrYQ3A7AEIAIgCSACQYgFaq2ENwOoBCACIAggAkEgaq2ENwOgBCACIAggAkEQaq2ENwOYBCACQdcAaiACQe8EaiIALQAAOgAAIAJBAzoAVCACQQA2AlAgAkIgNwJIIAJBAjYCQCACQQI2AjggAiACLwDtBDsAVSACQQM6ANQBIAJBADYC0AEgAkIgNwLIASACQQI2AsABIAJBAjYCuAEgAkEDOgC0ASACQQA2ArABIAJCoICAgDA3AqgBIAJBAjYCoAEgAkECNgKYASACQQM6AJQBIAJBADYCkAEgAkKggICAIDcCiAEgAkECNgKAASACQQI2AnggAkEDOgB0IAJBADYCcCACQqCAgIAQNwJoIAJBAjYCYCACQQI2AlggAkHXAWogAC0AADoAACACQQI2AtgBIAJBADYC8AEgAkECNgL4ASACQQI2AoACIAJBADYCkAIgAkECNgKYAiACQQA2ArACIAJBAjYCuAIgAkECNgLAAiACQQA2AtACIAJBAjYC2AIgAkECNgLgAiACQQA2AvACIAJCgYCAgJABNwLgASACQqCAgIAgNwLoASACQqCAgIDAADcCiAIgAkKBgICAkAE3AqACIAJCoICAgNAANwKoAiACQqCAgIDgADcCyAIgAkIgNwLoAiACQQM6APQCIAJBAzoA1AIgAkEDOgC0AiACQQM6AJQCIAJBAzoA9AEgAiACLwDtBDsA1QEgAkH3AmogAC0AACIDOgAAIAJBtwNqIAM6AAAgAkECNgL4AiACQQI2AoADIAJBADYCkAMgAkECNgKYAyACQQI2AqADIAJBADYCsAMgAkKggICA8AA3AogDIAJCIDcCqAMgAkEDOgC0AyACQQM6AJQDIAJBAjYCuAMgAkECNgLAAyACQQA2AtADIAJCIDcCyAMgAkEDOgDUAyACIAIvAO0EIgM7APUCIAIgAzsAtQMgAkHXA2ogAC0AADoAACACQQM6APQDIAJCoICAgIABNwLoAyACQQA2AvADIAJBAjYC4AMgAkECNgLYAyACQQ42AoQFIAJBDjYC9AQgAkGUhsAANgLwBCACQQo2AvwEIAIgAi8A7QQ7ANUDIAIgAkE4ajYCgAUgAiACQZgEajYC+AQgAkEEaiACQfAEahA2IAIoAqQFIgAEQCACKAKoBSAAEKkBCyACKAKYBSIARQ0BIAIoApwFIAAQqQEMAQsgAjUCGCEKIAIgBDYCiAUgAiAAKAIUIgU2AowFIAIgBTYClAUgAiAENgKQBSACQZgFaiIEIAAQIyACQaQFaiAAEC8gAiAKQiCGNwPgBCACIAhCgICAgBAiCIQ3A9gEIAIgCCAErYQ3A9AEIAIgAkE0aq1CgICAgMAAhDcDyAQgAiAJIAJBLGqthDcDwAQgAiAIIAOthDcDuAQgAiAJIAJBlAVqrYQ3A7AEIAIgCSACQYgFaq2ENwOoBCACIAggAkEgaq2ENwOgBCACIAggAkEQaq2ENwOYBCACQdcAaiACQe8EaiIALQAAOgAAIAJBAzoAVCACQQA2AlAgAkIgNwJIIAJBAjYCQCACQQI2AjggAiACLwDtBDsAVSACQQM6ANQBIAJBADYC0AEgAkIgNwLIASACQQI2AsABIAJBAjYCuAEgAkEDOgC0ASACQQA2ArABIAJCoICAgDA3AqgBIAJBAjYCoAEgAkECNgKYASACQQM6AJQBIAJBADYCkAEgAkKggICAIDcCiAEgAkECNgKAASACQQI2AnggAkEDOgB0IAJBADYCcCACQqCAgIAQNwJoIAJBAjYCYCACQQI2AlggAkHXAWogAC0AADoAACACQQI2AtgBIAJBADYC8AEgAkECNgL4ASACQQI2AoACIAJBADYCkAIgAkECNgKYAiACQQI2AqACIAJBADYCsAIgAkKBgICAkAE3AuABIAJCoICAgCA3AugBIAJCoICAgMAANwKIAiACQiA3AqgCIAJBAzoAtAIgAkEDOgCUAiACQQM6APQBIAIgAi8A7QQ7ANUBIAJBtwJqIAAtAAA6AAAgAkEDOgCUAyACQQM6APQCIAJBAzoA1AIgAkIgNwKIAyACQqCAgIDgADcC6AIgAkKggICA0AA3AsgCIAJCgYCAgJABNwLAAiACQQA2ApADIAJBAjYCgAMgAkECNgL4AiACQQA2AvACIAJBAjYC4AIgAkECNgLYAiACQQA2AtACIAJBAjYCuAIgAiACLwDtBDsAtQIgAkGXA2ogAC0AADoAACACIAIvAO0EOwCVAyACQQM6ANQDIAJBADYC0AMgAkIgNwLIAyACQQI2AsADIAJBAjYCuAMgAkEDOgC0AyACQQA2ArADIAJCoICAgPAANwKoAyACQQI2AqADIAJBAjYCmAMgAkHXA2ogAC0AADoAACACIAIvAO0EOwDVAyACQQM6APQDIAJBADYC8AMgAkIgNwLoAyACQQI2AuADIAJBAjYC2AMgAkH3A2ogAC0AADoAACACIAIvAO0EOwD1AyACQQM6AJQEIAJBADYCkAQgAkKggICAgAE3AogEIAJBAjYCgAQgAkECNgL4AyACQQ82AoQFIAJBDzYC9AQgAkGMh8AANgLwBCACIAJBOGo2AoAFIAJBCjYC/AQgAiACQZgEajYC+AQgAkEEaiACQfAEahA2IAIoAqQFIgAEQCACKAKoBSAAEKkBCyACKAKYBSIARQ0AIAIoApwFIAAQqQELIAIoAiAiAARAIAIoAiQgABCpAQsgAigCECIABEAgAigCFCAAEKkBCyACQQE2AjwgAkHkiMAANgI4IAJCATcCRCACIAggAkEEaq2ENwOYBCACIAJBmARqNgJAIAEoAhwgASgCICACQThqECogAigCBCIBBEAgAigCCCABEKkBCyACQbAFaiQAC/QNAQl/IAEoAkwhBCABKAJIIQcCQAJAAkAgASgCUCIFRQ0AIAQgBU0EQCAEIAVGDQEMAgsgBSAHaiwAAEG/f0wNAQtBASEKAkACQAJAIAQgBUYEQCAEIQMMAQsCfyAFIAdqIggsAAAiBkEATgRAIAZB/wFxDAELIAgtAAFBP3EhAiAGQR9xIQMgA0EGdCACciAGQV9NDQAaIAgtAAJBP3EgAkEGdHIhAiACIANBDHRyIAZBcEkNABogA0ESdEGAgPAAcSAILQADQT9xIAJBBnRycgsgBSEDQTBrQQlLDQAgASADQQFqIgM2AlACQCADRQ0AIAMgBE8EQCADIARGDQEMBAsgAyAHaiwAAEG/f0wNAwtBACEKIAMgBEYEQCAEIQMMAQsCfyADIAdqIgYsAAAiCUEATgRAIAlB/wFxDAELIAYtAAFBP3EhAiAJQR9xIQggCEEGdCACciAJQV9NDQAaIAYtAAJBP3EgAkEGdHIhAiACIAhBDHRyIAlBcEkNABogCEESdEGAgPAAcSAGLQADQT9xIAJBBnRycgtBMGtBCUsNACAFQQJqIQMgAQJ/A0ACQCADRQ0AIAMgBE8EQCADIARGDQEMBQsgAyAHaiwAAEG/f0wNBAsgBCADIARGDQEaAn8gAyAHaiIGLAAAIglBAE4EQCAJQf8BcQwBCyAJQR9xIQggBkEBai0AAEE/cSECIAhBBnQgAnIgCUFfTQ0AGiAGQQJqLQAAQT9xIAJBBnRyIQIgAiAIQQx0ciAJQXBJDQAaIAhBEnRBgIDwAHEgBkEDai0AAEE/cSACQQZ0cnILIANBAWohA0Ewa0EKSQ0ACyADQQFrCyIDNgJQCwJAAkACQAJAAkACQCAKDQACfwJAAkACQCADIARPDQAgAyAHai0AAEEuRw0AIAEgA0EBaiIDNgJQDAELIAMNAEEAIQMMAQsgAyAETwRAIAQgAyAERg0CGgwICyADIAdqLAAAQb9/TA0HCyAEIQICQCADIARGDQACfyADIAdqIggsAAAiBkEATgRAIAZB/wFxDAELIAgtAAFBP3EhAiAGQR9xIQUgBUEGdCACciAGQV9NDQAaIAgtAAJBP3EgAkEGdHIhAiACIAVBDHRyIAZBcEkNABogBUESdEGAgPAAcSAILQADQT9xIAJBBnRycgtBMGtBCUsEQCADIQIMAQsgBEEBayEIIAMhAgNAIAIiBUEBaiECAkAgBUF/Rg0AIAIgBE8EQCAFIAhGDQEMCQsgBSAHakEBaiwAAEG/f0wNCAsCQCAFIAhGBEAgBCECDAELAn8gBSAHaiIGQQFqLAAAIglBAE4EQCAJQf8BcQwBCyAJQR9xIQMgBkECai0AAEE/cSEFIANBBnQgBXIgCUFfTQ0AGiAGQQNqLQAAQT9xIAVBBnRyIQUgBSADQQx0ciAJQXBJDQAaIANBEnRBgIDwAHEgBkEEai0AAEE/cSAFQQZ0cnILQTBrQQpJDQELCyABIAI2AlALQQAgAkUNABogAiAETwRAIAQgAiAERg0BGgwFCyACIAdqLAAAQb9/TA0EIAILIgUgB2ohAwJAAkAgBCAFayICQQFNBEAgAkEBRg0BDAILIAMsAAFBQEgNAQsgAy0AACICQcEAa0H/AXFBGklBBXQgAnJB5QBHDQAgASAFQQFqIgU2AlALAkAgBUUNACAEIAVNBEAgBCAFRg0BDAoLIAUgB2osAABBv39MDQkLIAQgBUYNAQJ/IAUgB2oiCCwAACIGQQBOBEAgBkH/AXEMAQsgCC0AAUE/cSECIAZBH3EhAyADQQZ0IAJyIAZBX00NABogCC0AAkE/cSACQQZ0ciECIAIgA0EMdHIgBkFwSQ0AGiADQRJ0QYCA8ABxIAgtAANBP3EgAkEGdHJyC0Ewa0EJSw0BIARBAWshCANAIAUiAkEBaiEFAkAgAkF/Rg0AIAQgBU0EQCACIAhGDQEMBQsgAiAHakEBaiwAAEG/f0wNBAsgAiAIRgRAIAQhBQwCCwJ/IAIgB2oiBkEBaiwAACIJQQBOBEAgCUH/AXEMAQsgCUEfcSEDIAZBAmotAABBP3EhAiADQQZ0IAJyIAlBX00NABogBkEDai0AAEE/cSACQQZ0ciECIAIgA0EMdHIgCUFwSQ0AGiADQRJ0QYCA8ABxIAZBBGotAABBP3EgAkEGdHJyC0Ewa0EKSQ0ACwsgASAFNgJQCyAAIAE2AgQgACAKNgIADwsgASAFNgJQDAULIAcgBCACIARB4ITAABCbAQALIAEgBUEBaiIANgJQIAcgBCAAIARB0ITAABCbAQALDAMLIAEgAzYCUAwCCwwBCyAHIAQgBSAEQdCEwAAQmwEACyAHIAQgAyAEQdCEwAAQmwEAC6gNAQ9/IwBBIGsiECQAAkAgAUEhSQRAIAAgASACIAMQEAwBCyACQQFrIRIDQCAAQQFrIRUDQCAERQRAIAAgASACIANBASAGEAkMAwsgACABQQN2Ig9BB2xqIQcgACAPQQJ0aiEJIARBAWshBCAQAn8gAUHAAE8EQCAAIAkgByAPEF8MAQsgACAHIAkgAC0AACIPIAktAAAiCUkiCiAJIActAAAiB0lzGyAKIAcgD0tzGwsiEy0AACIOOgAHIBMgAGshDwJAAkACQAJAIAUEQCAFLQAAIA5PDQELIAEgA0sNAUEAIQkgACEHIAEgAmoiESEIIA8hCgNAIAAgCkEDayILQQAgCiALTxtqIgsgB0sEQANAIAIgCEEBayAHLQAAIgwgDkkiDRsgCWogDDoAACAJIA1qIgkgAiAIQQJrIActAAEiDCAOSSING2ogDDoAACAJIA1qIgkgAiAIQQNrIActAAIiDCAOSSING2ogDDoAACAJIA1qIgkgAiAIQQRrIgggBy0AAyIMIA5JIg0baiAMOgAAIAkgDWohCSAHQQRqIgcgC0kNAAsLIAAgCmoiCyAHSwRAIAogB2sgACAHaiALIAdrQQFxBH8gAiAIQQFrIgggBy0AACILIA5JIhQbIAlqIAs6AAAgCSAUaiEJIAdBAWoFIAcLIQtqIQwgByAKIBVqRwRAA0AgAiAIQQFrIAstAAAiByAOSSINGyAJaiAHOgAAIAkgDWoiByACIAhBAmsiCCALLQABIgkgDkkiDRtqIAk6AAAgByANaiEJIAtBAmoiCyAMRw0ACwsgDCEHCyABIApHBEAgCEEBayIIIAlqIActAAA6AAAgB0EBaiEHIAEhCgwBCwsgACACIAkQJSEOIAEgCWshDAJAIAEgCUYNACAMQQNxIQtBACEIIAkgAWtBfE0EQCAJIA5qIQ0gASASaiEKIAxBfHEhFANAIAggDWoiByAKLQAAOgAAIAdBAWogESAIQX5zai0AADoAACAHQQJqIBEgCEF9c2otAAA6AAAgB0EDaiARIAhBfHNqLQAAOgAAIApBBGshCiAUIAhBBGoiCEcNAAsLIAtFDQAgEiABIAhraiEHIAggDmogCWohCANAIAggBy0AADoAACAHQQFrIQcgCEEBaiEIIAtBAWsiCw0ACwsgCUUNACABIAlPDQIgEEEANgIYIBBBATYCDCAQQfigwAA2AgggEEIENwIQIBBBCGpBgKHAABCFAQALIAEgA0sNAEEAIQogACEHIAEgAmoiDiEIA0AgACAPQQNrIgVBACAFIA9NG2oiCSAHSwRAIBMtAAAhBQNAIAIgCEEBayAFIActAAAiC08iDBsgCmogCzoAACAKIAxqIgogAiAIQQJrIAUgBy0AASILTyIMG2ogCzoAACAKIAxqIgogAiAIQQNrIAUgBy0AAiILTyIMG2ogCzoAACAKIAxqIgogAiAIQQRrIgggBSAHLQADIgtPIgwbaiALOgAAIAogDGohCiAHQQRqIgcgCUkNAAsLIAAgD2oiBSAHSwRAIA8gB2sgACAHaiATLQAAIQsgBSAHa0EBcQR/IAIgCEEBayIIIAsgBy0AACIFTyINGyAKaiAFOgAAIAogDWohCiAHQQFqBSAHCyEJaiEFIAcgDyAVakcEQANAIAIgCEEBayAJLQAAIgcgC00iDBsgCmogBzoAACAKIAxqIgcgAiAIQQJrIgggCyAJLQABIgpPIgwbaiAKOgAAIAcgDGohCiAJQQJqIgkgBUcNAAsLIAUhBwsgASAPRwRAIAIgCmogBy0AADoAACAHQQFqIQcgCkEBaiEKIAhBAWshCCABIQ8MAQsLIAAgAiAKECUhACABIAprIQkCQCABIApGDQAgCUEDcSEFQQAhCCAKIAFrQXxNBEAgACAKaiEPIAEgEmohCyAJQXxxIQwDQCAIIA9qIgcgCy0AADoAACAHQQFqIA4gCEF+c2otAAA6AAAgB0ECaiAOIAhBfXNqLQAAOgAAIAdBA2ogDiAIQXxzai0AADoAACALQQRrIQsgDCAIQQRqIghHDQALCyAFRQ0AIBIgCGsgAWohByAAIAhqIApqIQgDQCAIIActAAA6AAAgB0EBayEHIAhBAWohCCAFQQFrIgUNAAsLIAEgCk8EQCAAIApqIQBBACEFIAkiAUEhTw0FDAMLIAogAUGQocAAEKoBAAsACyAJIA5qIAwgAiADIAQgEEEHaiAGEAUgCSIBQSFPDQELCwsgACAJIAIgAxAQCyAQQSBqJAALmQwBD38gASgCUCILIAEoAlQiDkYEQCABKAIUIQ0gASgCICEMCyABKAIIIQgCQCABLQBYQQJHBEAgCCEKDAELIAghCiABLQBZRQ0AIAEoAgAgCEYEQCABQZiDwAAQTAsgASgCBCAIQQxsaiICIAs2AgggAkEANgIEIAJBADoAACABIAhBAWoiCjYCCCABKAJUIQ4LIAsgDkYEQCABKAIgIAEoAhRqIQ8LIAEoAkwhAyABKAJIIQkCQAJAAkAgASgCUCIGRQ0AIAMgBk0EQCADIAZGDQEMAgsgBiAJaiwAAEG/f0wNAQtBASEQAkACQAJAAkAgAyAGRg0AIAYgCWoiBCwAACIFQQBOIAVBYElyDQAgBUEfcSEHIAQtAAJBP3EgBC0AAUE/cUEGdHIhAiAFQXBJBH8gAiAHQQx0cgUgB0ESdEGAgPAAcSAELQADQT9xIAJBBnRycgtBgJwBa0GlowFLDQAgASAGQQNqIgI2AlACQCACRQ0AIAIgA08EQCACIANGDQEMBQsgAiAJaiwAAEG/f0wNBAtBACEQIAIgA0YNASACIAlqIgQsAAAiBUEATiAFQWBJcg0BIAVBH3EhByAELQACQT9xIAQtAAFBP3FBBnRyIQIgBUFwSQR/IAIgB0EMdHIFIAdBEnRBgIDwAHEgBC0AA0E/cSACQQZ0cnILQYCcAWtBpaMBSw0BIAEgBkEGaiICNgJQAkAgAkUNACACIANPBEAgAiADRg0BDAcLIAIgCWosAABBv39MDQYLIAIgA0YNACACIAlqIgQsAAAiBUEATiAFQWBJcg0AIAVBH3EhByAELQACQT9xIAQtAAFBP3FBBnRyIQIgBUFwSQR/IAIgB0EMdHIFIAdBEnRBgIDwAHEgBC0AA0E/cSACQQZ0cnILQYCcAWtBpaMBSw0AIAZBCWohAgJAA0ACQCACRQ0AIAIgA08EQCACIANGDQEMBgsgAiAJaiwAAEG/f0wNBQsgAiADRg0BIAIgCWoiBiwAACIEQQBOBEAgAiEDDAILIARBYEkEQCACIQMMAgsgBEEfcSEFIAZBAmotAABBP3EgBkEBai0AAEE/cUEGdHIhByAEQXBJBH8gByAFQQx0cgUgBUESdEGAgPAAcSAGQQNqLQAAQT9xIAdBBnRycgtBgJwBa0GmowFJBEAgAkEDaiECDAELCyACIQMLIAEgAzYCUAsgASAKNgIICyABLQBYIQICQAJAAkACQAJAIBBFBEAgAkH/AXFBAUcNASABLQBZRQ0DAkAgCyAORgRAIA8gASgCICICIAEoAhQiCmoiA0kgAyAPa0EBRnENBSAKIA1PBEAgASANNgIUCyACIAxJDQEgASAMNgIgIAwhAgwBCyALIA5NDQQgASALNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBAjoAACABIAJBAWo2AiAgAS0AWCECDAELIAJB/wFxQQFGDQICQCABLQBZRQ0AAkAgCyAORgRAIA8gASgCICIHIAEoAhQiA2oiCkkgCiAPa0EBRnENAiADIA1PBEAgASANNgIUIA0hAwsgByAMSQ0BIAEgDDYCIAwBCyALIA5NDQEgASALNgJUQQAhAyABQQA2AiAgAUEANgIUCyABKAIMIANGBEAgAUEMakGAhMAAEFILIAEoAhAgA2pBAjoAACABIANBAWo2AhQgAS0AWCECCyACQf8BcUECRw0CIAEtAFlFDQIgASgCCCAITw0BDAILIAJB/wFxQQJHDQEgAS0AWUUNASAIIAEoAggiA08NAiABKAIEIAhBDGxqIgItAAANAyACIAM2AgQgASgCUCECIAEoAggiCiABKAIARgRAIAFBuIPAABBMCyABKAIEIApBDGxqIgMgAjYCCCADIAg2AgQgA0GBBDsBACAKQQFqIQgLIAEgCDYCCAsgACABNgIEIAAgEDYCAA8LIAggA0Gog8AAEGkAC0HIg8AAQShB8IPAABB7AAsgASACNgJQDAILDAELIAkgAyAGIANB0ITAABCbAQALIAkgAyACIANB0ITAABCbAQALkwsBD38gASgCUCIKIAEoAlQiDkYEQCABKAIgIQ0gASgCFCELCyABKAIIIQcCQCABLQBYQQJHBEAgByEFDAELIAchBSABLQBZRQ0AIAEoAgAgB0YEQCABQZiDwAAQTAsgASgCBCAHQQxsaiIFIAo2AgggBUEANgIEIAVBADoAACABIAdBAWoiBTYCCCABKAJUIQ4LIAogDkYEQCABKAIgIAEoAhRqIQ8LIAEoAkwhAiABKAJIIQQCQAJAAkAgASgCUCIGRQ0AIAIgBk0EQCACIAZGDQEMAgsgBCAGaiwAAEG/f0wNAQsgBCAGaiEIAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkAgAiAGRg0AAn8gCCwAACIDQQBOBEAgA0H/AXEMAQsgCC0AAUE/cSEJIANBH3EhDCAMQQZ0IAlyIANBX00NABogCC0AAkE/cSAJQQZ0ciEJIAkgDEEMdHIgA0FwSQ0AGiAMQRJ0QYCA8ABxIAgtAANBP3EgCUEGdHJyC0H+//8AcUEwRw0AAkAgBkEBaiIDRQ0AIAIgA00EQCACIANGDQEMDgsgAyAEaiwAAEG/f0wNDQsgAiADRg0AAn8gAyAEaiIMLAAAIgNBAE4EQCADQf8BcQwBCyAMLQABQT9xIRAgA0EfcSEJIAlBBnQgEHIgA0FfTQ0AGiAMLQACQT9xIBBBBnRyIRAgECAJQQx0ciADQXBJDQAaIAlBEnRBgIDwAHEgDC0AA0E/cSAQQQZ0cnILQTBrQQpJDQELIAEgBTYCCEEBIQUgAiAGTQ0BIAgtAABBMkcNAQJAIAIgBkEBaiIDTQRAIAIgA0YNAQwPCyADIARqLAAAQb9/TA0OCyACIANGDQECfyADIARqIgQsAAAiAkEATgRAIAJB/wFxDAELIAQtAAFBP3EhCCACQR9xIQMgA0EGdCAIciACQV9NDQAaIAQtAAJBP3EgCEEGdHIhCCAIIANBDHRyIAJBcEkNABogA0ESdEGAgPAAcSAELQADQT9xIAhBBnRycgtB/P//AHFBMEcNAQsgASAGQQJqNgJQIAEtAFgiAkEBRg0BDAULIAEtAFgiAkEBRg0GIAEtAFlFDQMgCiAORw0BIA8gASgCICIGIAEoAhQiBGoiA0kgAyAPa0EBRnENAyAEIAtPBEAgASALNgIUIAshBAsgBiANSQ0CIAEgDTYCIAwCC0EAIQUgAS0AWUUNBQJAIAogDkYEQCAPIAEoAiAiAiABKAIUIgRqIgZJIAYgD2tBAUZxDQcgBCALTwRAIAEgCzYCFAsgAiANSQ0BIAEgDTYCICANIQIMAQsgCiAOTQ0GIAEgCjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCGCACRgRAIAFBGGpBgITAABBSCyABKAIcIAJqQRQ6AAAgASACQQFqNgIgIAEtAFghAgwDCyAKIA5NDQEgASAKNgJUQQAhBCABQQA2AiAgAUEANgIUCyABKAIMIARGBEAgAUEMakGAhMAAEFILIAEoAhAgBGpBFDoAACABIARBAWo2AhQgAS0AWCECCyACQf8BcUECRw0CIAEtAFlFDQJBASABKAIIIAdPDQEaDAILQQAhBSACQf8BcUECRw0BIAEtAFlFDQEgByABKAIIIgVPDQIgASgCBCAHQQxsaiICLQAADQMgAiAFNgIEIAEoAlAhBCABKAIIIgUgASgCAEYEQCABQbiDwAAQTAsgASgCBCAFQQxsaiICIAQ2AgggAiAHNgIEIAJBgSg7AQAgBUEBaiEHQQALIQUgASAHNgIICyAAIAE2AgQgACAFNgIADwsgByAFQaiDwAAQaQALQciDwABBKEHwg8AAEHsACwwBCyAEIAIgBiACQdCEwAAQmwEACyAEIAIgAyACQdCEwAAQmwEAC5EKAQx/IwBBMGsiBCQAIAEoAlAiByABKAJUIgNGBEAgASgCICEJIAEoAhQhBgsgASgCCCEIAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAIRgRAIAFBmIPAABBMCyABKAIEIAhBDGxqIgIgBzYCCCACQQA2AgQgAkEAOgAAIAEgCEEBajYCCCABKAJUIQMLIAMgB0YEQCABKAIgIAEoAhRqIQoLIARBKGogARALIAQoAiwhAQJAAkACQAJAIAQoAihFDQAgBEEgaiABEBYgBCgCJCEBIAQoAiBFDQAgBEEYaiABEBcgBCgCHCEBIAQoAhhFDQAgBEEQaiABEA8gBCgCFCEBIAQoAhBFDQAgBEEIaiABEBggBCgCDCEBIAQoAghFDQAgBCABEBkgBCgCBCEBIAQoAgBFDQAgASgCTCEDIAEoAkghCwJAIAEoAlAiAkUNACACIANPBEAgAiADRg0BDAULIAIgC2osAABBv39MDQQLIAIgC2ohBQJAAkACQCADIAJrIg1BA00EQCANQQNGDQEMAgsgBSwAA0FASA0BCyAFLQAAIgxBwQBrQf8BcUEaSUEFdCAMckHhAEcNACAFLQABIgxBwQBrQf8BcUEaSUEFdCAMckEuRw0AIAUtAAIiDEHBAGtB/wFxQRpJQQV0IAxyQe0ARg0BCwJAIAJFDQAgAiADTwRAIAIgA0YNAQwGCyAFLAAAQb9/TA0FCwJAIA1BA00EQCANQQNGDQEMBAsgBSwAA0FASA0DCyAFLQAAIgNBwQBrQf8BcUEaSUEFdCADckHwAEcNAiAFLQABIgNBwQBrQf8BcUEaSUEFdCADckEuRw0CIAUtAAIiA0HBAGtB/wFxQRpJQQV0IANyQe0ARw0CCyABIAJBA2o2AlALIAEtAFgiBUEBRgRAQQAhAyABLQBZRQ0CAkAgByABKAJUIgJGBEAgCiABKAIgIgIgASgCFCIFaiIHSSAHIAprQQFGcQ0EIAUgBk8EQCABIAY2AhQLIAIgCUkNASABIAk2AiAgCSECDAELIAIgB08NAyABIAc2AlRBACECIAFBADYCICABQQA2AhQLIAEoAhggAkYEQCABQRhqQYCEwAAQUgsgASgCHCACakEXOgAAIAEgAkEBajYCICABLQBYIQULQQAhAyAFQQJHDQEgAS0AWUUNAQJAIAEoAggiAiAISwRAIAEoAgQgCEEMbGoiBi0AAA0BIAYgAjYCBCABKAJQIQkgASgCCCICIAEoAgBGBEAgAUG4g8AAEEwLIAEoAgQgAkEMbGoiBiAJNgIIIAYgCDYCBCAGQYEuOwEAIAEgAkEBajYCCAwDCyAIIAJBqIPAABBpAAtByIPAAEEoQfCDwAAQewALQQEhAyABLQBYIgVBAUYNAAJAIAEtAFlFDQACQCAHIAEoAlQiAkYEQCAKIAEoAiAiByABKAIUIgJqIgtJIAsgCmtBAUZxDQIgAiAGTwRAIAEgBjYCFCAGIQILIAcgCUkNASABIAk2AiAMAQsgAiAHTw0BIAEgBzYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQRc6AAAgASACQQFqNgIUIAEtAFghBQsgBUECRw0AIAEtAFlFDQAgASgCCCAISQ0AIAEgCDYCCAsgACABNgIEIAAgAzYCACAEQTBqJAAPCyALIAMgAiADQeCEwAAQmwEAC6AJAhF/An4jAEHQAmsiESQAAkAgAUECSQ0AIAGtIhdC//////////8/fCAXgCEYAn8gAUGBIE8EQEEBQSAgAUEBcmdrQQF2IgZ0IAEgBnZqQQF2DAELQcAAIAEgAUEBdmsiBiAGQcAATxsLIRIgAEEBayEWQQEhCgNAQQAhE0EBIQcgASAPSwRAIAAgD2ohDSAPrSIXAn8CQCABIA9rIgcgEkkNAAJAIAdBAkkEQCAHIQYMAQsCfwJAAkAgDS0AASIIIA0tAABJIhBFBEBBAiEGIAdBAkYNBANAIAhB/wFxIAYgDWotAAAiCEsNAyAHIAZBAWoiBkcNAAsMAQtBAiEGQQEgB0ECRg0CGgNAIAhB/wFxIAYgDWotAAAiCE0NAiAHIAZBAWoiBkcNAAsLIAchBgsgBiASSQ0CIBBFDQEgBkECSQRAQQEhBgwCCyAGQQF2CyELIAYgDWohFEEAIQwgC0EBRwRAIAZBAWshCCALQf7///8HcSEVA0AgCCANaiIQLQAAIQcgECAMIA1qIg4tAAA6AAAgDiAHOgAAIBQgDEF+c2oiBy0AACEQIAcgDkEBaiIHLQAAOgAAIAcgEDoAACAIQQJrIQggFSAMQQJqIgxHDQALCyALQQFxRQ0AIAwgDWoiBy0AACEQIAcgFCAMQX9zaiIHLQAAOgAAIAcgEDoAAAsgBkEBdEEBcgwBCyASIAcgByASSxtBAXQgBEUNABogDUEgIAcgB0EgTxsiBiACIANBAEEAIAUQBSAGQQF0QQFyCyIHQQF2IA9qrXwgGH4gDyAKQQF2a60gF3wgGH6FeachEwsCQAJAIAlBAkkNACAPIBZqIRAgACAPaiEUA0AgCUEBayIVIBFBjgJqai0AACATSQ0BAn8CQAJAAkAgAyARQQRqIBVBAnRqKAIAIglBAXYiCCAKQQF2IgZqIg1PIAkgCnJBAXFFcUUEQCAAIA8gDWtqIQ4gCUEBcUUEQCAOIAggAiADIAhBAXJnQQF0QT5zQQAgBRAFCyAKQQFxRQRAIAggDmogBiACIAMgBkEBcmdBAXRBPnNBACAFEAULIApBAkkgCUECSXINAyAGIAggBiAISSIMIgYbIgsgA0sNAyACIAggDmoiCSAOIAYbIAsQJSIKIAtqIQYgDARAIBAhDANAIAwgBkEBayIGLQAAIgggCUEBayIJLQAAIgsgCCALSxs6AAAgBiAIIAtJaiEGIAkgCCALT2oiCSAORg0DIAxBAWshDCAGIApHDQALDAILIAtFDQIDQCAOIAktAAAiCCAKLQAAIgsgCCALSSIMGzoAACAOQQFqIQ4gCiAIIAtPaiIKIAZGDQMgCSAMaiIJIBRHDQALDAILIA1BAXQMAwsgCSEOCyAOIAogBiAKaxAlGgsgDUEBdEEBcgshCkEBIQYgFSIJQQFLDQALDAELIAkhBgsgEUGOAmogBmogEzoAACARQQRqIAZBAnRqIAo2AgAgASAPSwRAIAZBAWohCSAHQQF2IA9qIQ8gByEKDAELCyAKQQFxDQAgACABIAIgAyABQQFyZ0EBdEE+c0EAIAUQBQsgEUHQAmokAAu9CQEOfyABKAJQIgUgASgCVCILRgRAIAEoAiAhDCABKAIUIQkLIAEoAgghBgJAIAEtAFhBAkcEQCAGIQMMAQsgBiEDIAEtAFlFDQAgASgCACADRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgMgBTYCCCADQQA2AgQgA0EAOgAAIAEgBkEBaiIDNgIIIAEoAlQhCwsgBSALRgRAIAEoAiAgASgCFGohDQsgASgCTCECIAEoAkghCAJAAkAgASgCUCIHRQ0AIAIgB00EQCACIAdGDQEMAgsgByAIaiwAAEG/f0wNAQsCQAJ/AkAgAiAHRg0AAn8gByAIaiIKLAAAIgRBAE4EQCAEQf8BcQwBCyAKLQABQT9xIQ4gBEEfcSEPIA9BBnQgDnIgBEFfTQ0AGiAKLQACQT9xIA5BBnRyIQ4gDiAPQQx0ciAEQXBJDQAaIA9BEnRBgIDwAHEgCi0AA0E/cSAOQQZ0cnILQTBrQQVLDQACQCAHQQFqIgRFDQAgAiAETQRAIAIgBEYNAQwECyAEIAhqLAAAQb9/TA0DCyACIARGDQACfyAEIAhqIggsAAAiAkEATgRAIAJB/wFxDAELIAgtAAFBP3EhCiACQR9xIQQgBEEGdCAKciACQV9NDQAaIAgtAAJBP3EgCkEGdHIhCiAKIARBDHRyIAJBcEkNABogBEESdEGAgPAAcSAILQADQT9xIApBBnRycgtBMGtBCUsNACABIAdBAmo2AlBBAAwBCyABIAM2AghBAQshByABLQBYIQICQAJAAkACQAJAIAdFBEAgAkH/AXFBAUcNASABLQBZRQ0DAkAgBSALRgRAIA0gASgCICICIAEoAhQiA2oiBUkgBSANa0EBRnENBSADIAlPBEAgASAJNgIUCyACIAxJDQEgASAMNgIgIAwhAgwBCyAFIAtNDQQgASAFNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBFToAACABIAJBAWo2AiAgAS0AWCECDAELIAJB/wFxQQFGDQICQCABLQBZRQ0AAkAgBSALRgRAIA0gASgCICIFIAEoAhQiA2oiC0kgCyANa0EBRnENAiADIAlPBEAgASAJNgIUIAkhAwsgBSAMSQ0BIAEgDDYCIAwBCyAFIAtNDQEgASAFNgJUQQAhAyABQQA2AiAgAUEANgIUCyABKAIMIANGBEAgAUEMakGAhMAAEFILIAEoAhAgA2pBFToAACABIANBAWo2AhQgAS0AWCECCyACQf8BcUECRw0CIAEtAFlFDQIgASgCCCAGTw0BDAILIAJB/wFxQQJHDQEgAS0AWUUNASAGIAEoAggiA08NAiABKAIEIAZBDGxqIgItAAANAyACIAM2AgQgASgCUCEJIAEoAggiAyABKAIARgRAIAFBuIPAABBMCyABKAIEIANBDGxqIgIgCTYCCCACIAY2AgQgAkGBKjsBACADQQFqIQYLIAEgBjYCCAsgACABNgIEIAAgBzYCAA8LIAYgA0Gog8AAEGkAC0HIg8AAQShB8IPAABB7AAsgCCACIAQgAkHQhMAAEJsBAAsgCCACIAcgAkHQhMAAEJsBAAu6CQEMfyMAQSBrIgQkACABKAJQIgIgASgCVCIDRgRAIAEoAiAhCSABKAIUIQYLIAEoAgghBwJAIAEtAFhBAkcEQCAHIQUMAQsgByEFIAEtAFlFDQAgASgCACAHRgRAIAFBmIPAABBMCyABKAIEIAdBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgB0EBaiIFNgIIIAEoAlQhAwsgAiADRgRAIAEoAiAgASgCFGohCwsCQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAFkiCEUEQCABKAJIIQgCQCABKAJQIgMgASgCTCIMTw0AIAMgCGotAABB4ABHDQAgASADQQFqNgJQIARBCGogARAwIAQoAgwhASAEKAIIRQRAA0AgBCABEDAgBCgCBCEBIAQoAgBFDQALCyABKAJQIgogASgCTE8NACABKAJIIApqLQAAQeAARw0AIAEgCkEBajYCUAwCCyABIAM2AlAgASAMNgJMIAEgCDYCSCABKAIIIAVJDQMgASAFNgIIDAMLIAFBADoAWSABKAJIIQogASgCUCIDIAEoAkwiDU8NASADIApqLQAAQeAARw0BIAEgA0EBajYCUCAEQRhqIAEQMCAEKAIcIQEgBCgCGEUEQANAIARBEGogARAwIAQoAhQhASAEKAIQRQ0ACwsgASgCUCIMIAEoAkxPDQEgASgCSCAMai0AAEHgAEcNASABIAg6AFkgASAMQQFqNgJQCyABLQBYIgNBAUYNAgwGCyABIAM2AlAgASANNgJMIAEgCjYCSCAFIAEoAghNBEAgASAFNgIICyABIAg6AFkLQQEhBSABLQBYIgNBAUYNBSABLQBZRQ0DIAEoAlQiCCACRw0BIAsgASgCICIIIAEoAhQiAmoiCkkgCiALa0EBRnENAyACIAZPBEAgASAGNgIUIAYhAgsgCCAJSQ0CIAEgCTYCIAwCC0EAIQUgAS0AWUUNBAJAIAIgASgCVCIDRgRAIAsgASgCICICIAEoAhQiA2oiCEkgCCALa0EBRnENBiADIAZPBEAgASAGNgIUCyACIAlJDQEgASAJNgIgIAkhAgwBCyACIANNDQUgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBDDoAACABIAJBAWo2AiAgAS0AWCEDDAMLIAIgCE0NASABIAI2AlRBACECIAFBADYCICABQQA2AhQLIAEoAgwgAkYEQCABQQxqQYCEwAAQUgsgASgCECACakEMOgAAIAEgAkEBajYCFCABLQBYIQMLIANB/wFxQQJHDQEgAS0AWUUNASABKAIIIAdJDQEgASAHNgIIDAELQQAhBSADQf8BcUECRw0AIAEtAFlFDQAgByABKAIIIgJPDQEgASgCBCAHQQxsaiIGLQAADQIgBiACNgIEIAEoAlAhCSABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIGIAk2AgggBiAHNgIEIAZBgRg7AQAgASACQQFqNgIICyAAIAE2AgQgACAFNgIAIARBIGokAA8LIAcgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAv4CAELfyMAQTBrIgQkACABKAJQIgMgASgCVCIFRgRAIAEoAiAhCSABKAIUIQcLIAEoAgghBgJAIAEtAFhBAkcEQCAGIQIMAQsgBiECIAEtAFlFDQAgASgCACACRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgIgAzYCCCACQQA2AgQgAkEAOgAAIAEgBkEBaiICNgIIIAEoAlQhBQsgAyAFRgRAIAEoAiAgASgCFGohCgsgASgCUCEFIAEoAkwhCCABKAJIIQsgBEEoaiABEDIgBCgCLCEBAkACQAJAAkACQAJAAkACQCAEKAIoIgxFBEAgBEEgaiABEDIgBCgCJCEBAkAgBCgCIA0AIAEoAlAhBSABKAJMIQggASgCSCELIAEoAgghAiAEQRhqIAEQMiAEKAIcIQEgBCgCGEUEQCABKAJQIQUgASgCTCEIIAEoAkghCyABKAIIIQIgBEEQaiABEDIgBCgCFCEBIAQoAhBFBEADQCABKAJQIQUgASgCTCEIIAEoAkghCyABKAIIIQIgBEEIaiABEDIgBCgCDCEBIAQoAghFDQALCyABIAU2AlAgASAINgJMIAEgCzYCSCABKAIIIAJJDQEgASACNgIIDAELIAEgBTYCUCABIAg2AkwgASALNgJIIAEoAgggAkkNACABIAI2AggLIAEtAFgiAkEBRg0BDAULIAEgBTYCUCABIAg2AkwgASALNgJIIAIgASgCCE0EQCABIAI2AggLIAEtAFgiAkEBRg0FIAEtAFlFDQMgASgCVCIFIANHDQEgCiABKAIgIgUgASgCFCIDaiIISSAIIAprQQFGcQ0DIAMgB08EQCABIAc2AhQgByEDCyAFIAlJDQIgASAJNgIgDAILIAEtAFlFDQQCQCADIAEoAlQiAkYEQCAKIAEoAiAiAyABKAIUIgJqIgVJIAUgCmtBAUZxDQYgAiAHTwRAIAEgBzYCFAsgAyAJSQ0BIAEgCTYCICAJIQMMAQsgAiADTw0FIAEgAzYCVEEAIQMgAUEANgIgIAFBADYCFAsgASgCGCADRgRAIAFBGGpBgITAABBSCyABKAIcIANqQQM6AAAgASADQQFqNgIgIAEtAFghAgwDCyADIAVNDQEgASADNgJUQQAhAyABQQA2AiAgAUEANgIUCyABKAIMIANGBEAgAUEMakGAhMAAEFILIAEoAhAgA2pBAzoAACABIANBAWo2AhQgAS0AWCECCyACQf8BcUECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyACQf8BcUECRw0AIAEtAFlFDQAgBiABKAIIIgJPDQEgASgCBCAGQQxsaiIDLQAADQIgAyACNgIEIAEoAlAhByABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIDIAc2AgggAyAGNgIEIANBgQY7AQAgASACQQFqNgIICyAAIAE2AgQgACAMNgIAIARBMGokAA8LIAYgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAv4CAELfyMAQTBrIgQkACABKAJQIgMgASgCVCIFRgRAIAEoAiAhCSABKAIUIQcLIAEoAgghBgJAIAEtAFhBAkcEQCAGIQIMAQsgBiECIAEtAFlFDQAgASgCACACRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgIgAzYCCCACQQA2AgQgAkEAOgAAIAEgBkEBaiICNgIIIAEoAlQhBQsgAyAFRgRAIAEoAiAgASgCFGohCgsgASgCUCEFIAEoAkwhCCABKAJIIQsgBEEoaiABECggBCgCLCEBAkACQAJAAkACQAJAAkACQCAEKAIoIgxFBEAgBEEgaiABECggBCgCJCEBAkAgBCgCIA0AIAEoAlAhBSABKAJMIQggASgCSCELIAEoAgghAiAEQRhqIAEQKCAEKAIcIQEgBCgCGEUEQCABKAJQIQUgASgCTCEIIAEoAkghCyABKAIIIQIgBEEQaiABECggBCgCFCEBIAQoAhBFBEADQCABKAJQIQUgASgCTCEIIAEoAkghCyABKAIIIQIgBEEIaiABECggBCgCDCEBIAQoAghFDQALCyABIAU2AlAgASAINgJMIAEgCzYCSCABKAIIIAJJDQEgASACNgIIDAELIAEgBTYCUCABIAg2AkwgASALNgJIIAEoAgggAkkNACABIAI2AggLIAEtAFgiAkEBRg0BDAULIAEgBTYCUCABIAg2AkwgASALNgJIIAIgASgCCE0EQCABIAI2AggLIAEtAFgiAkEBRg0FIAEtAFlFDQMgASgCVCIFIANHDQEgCiABKAIgIgUgASgCFCIDaiIISSAIIAprQQFGcQ0DIAMgB08EQCABIAc2AhQgByEDCyAFIAlJDQIgASAJNgIgDAILIAEtAFlFDQQCQCADIAEoAlQiAkYEQCAKIAEoAiAiAyABKAIUIgJqIgVJIAUgCmtBAUZxDQYgAiAHTwRAIAEgBzYCFAsgAyAJSQ0BIAEgCTYCICAJIQMMAQsgAiADTw0FIAEgAzYCVEEAIQMgAUEANgIgIAFBADYCFAsgASgCGCADRgRAIAFBGGpBgITAABBSCyABKAIcIANqQRk6AAAgASADQQFqNgIgIAEtAFghAgwDCyADIAVNDQEgASADNgJUQQAhAyABQQA2AiAgAUEANgIUCyABKAIMIANGBEAgAUEMakGAhMAAEFILIAEoAhAgA2pBGToAACABIANBAWo2AhQgAS0AWCECCyACQf8BcUECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyACQf8BcUECRw0AIAEtAFlFDQAgBiABKAIIIgJPDQEgASgCBCAGQQxsaiIDLQAADQIgAyACNgIEIAEoAlAhByABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIDIAc2AgggAyAGNgIEIANBgTI7AQAgASACQQFqNgIICyAAIAE2AgQgACAMNgIAIARBMGokAA8LIAYgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAu7CAEMfyABKAJQIgIgASgCVCIHRgRAIAEoAiAhCiABKAIUIQgLIAEoAgghBgJAIAEtAFhBAkcEQCAGIQQMAQsgBiEEIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgQgAjYCCCAEQQA2AgQgBEEAOgAAIAEgBkEBaiIENgIIIAEoAlQhBwsgAiAHRgRAIAEoAiAgASgCFGohCwsCQAJAAkACfwJAAkACQAJAAkACQCABKAJQIgMgASgCTCIJSQRAIANBAWohBQJAAkAgASgCSCIMIANqIg0tAABBKkYEQCABIAU2AlAgBSAJTw0CIAUgDGotAABBKkcNAiABIANBAmoiBTYCUCAFIAlPDQEgBSAMai0AAEEqRw0BIANBA2ohAwNAIAEgAzYCUCADIAlGDQIgAyAMaiADQQFqIQMtAABBKkYNAAsMAQsgASAENgIIIA0tAABB3wBHDQMgASAFNgJQIAUgCU8NASAFIAxqLQAAQd8ARw0BIAEgA0ECaiIFNgJQIAUgCU8NACAFIAxqLQAAQd8ARw0AIANBA2ohAwNAIAEgAzYCUCADIAlGDQEgAyAMaiADQQFqIQMtAABB3wBGDQALCyABIAQ2AggLIAEtAFgiA0EBRg0CDAYLIAEgBDYCCAtBASEEIAEtAFgiA0EBRg0GIAEtAFlFDQMgAiAHRw0BIAsgASgCICIHIAEoAhQiAmoiCUkgCSALa0EBRnENAyACIAhPBEAgASAINgIUIAghAgsgByAKSQ0CIAEgCjYCIAwCC0EAIQQgAS0AWUUNBQJAIAIgB0YEQCALIAEoAiAiAiABKAIUIgNqIgdJIAcgC2tBAUZxDQcgAyAITwRAIAEgCDYCFAsgAiAKSQ0BIAEgCjYCICAKIQIMAQsgAiAHTQ0GIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCGCACRgRAIAFBGGpBgITAABBSCyABKAIcIAJqQQg6AAAgASACQQFqNgIgIAEtAFghAwwDCyACIAdNDQEgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIMIAJGBEAgAUEMakGAhMAAEFILIAEoAhAgAmpBCDoAACABIAJBAWo2AhQgAS0AWCEDCyADQf8BcUECRw0CIAEtAFlFDQJBASABKAIIIAZPDQEaDAILQQAhBCADQf8BcUECRw0BIAEtAFlFDQEgBiABKAIIIgJPDQIgASgCBCAGQQxsaiIELQAADQMgBCACNgIEIAEoAlAhCCABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIEIAg2AgggBCAGNgIEIARBgRA7AQAgAkEBaiEGQQALIQQgASAGNgIICyAAIAE2AgQgACAENgIADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC9sIAQt/IwBBMGsiBCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEJIAEoAhQhBwsgASgCCCEGAkAgAS0AWEECRwRAIAYhAwwBCyAGIQMgAS0AWUUNACABKAIAIANGBEAgAUGYg8AAEEwLIAEoAgQgBkEMbGoiAyACNgIIIANBADYCBCADQQA6AAAgASAGQQFqIgM2AgggASgCVCEFCyACIAVGBEAgASgCICABKAIUaiEKCwJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AWSIFRQRAIAEoAlAhBSABKAJMIQggASgCSCELIARBEGogARASIAQoAhQhASAEKAIQRQRAIARBCGogARAtIAQoAgwhASAEKAIIDQIDQCAEIAEQLSAEKAIEIQEgBCgCAEUNAAsMAgsgASAFNgJQIAEgCDYCTCABIAs2AkggASgCCCADSQ0DIAEgAzYCCAwDCyABQQA6AFkgASgCSCEIIAEoAkwhCyABKAJQIQwgBEEoaiABEBIgBCgCLCEBIAQoAigNASAEQSBqIAEQLSAEKAIkIQEgBCgCIEUEQANAIARBGGogARAtIAQoAhwhASAEKAIYRQ0ACwsgASAFOgBZCyABLQBYIgNBAUYNAgwGCyABIAw2AlAgASALNgJMIAEgCDYCSCADIAEoAghNBEAgASADNgIICyABIAU6AFkLQQEhBSABLQBYIgNBAUYNBSABLQBZRQ0DIAEoAlQiCCACRw0BIAogASgCICIIIAEoAhQiAmoiC0kgCyAKa0EBRnENAyACIAdPBEAgASAHNgIUIAchAgsgCCAJSQ0CIAEgCTYCIAwCC0EAIQUgAS0AWUUNBAJAIAIgASgCVCIDRgRAIAogASgCICICIAEoAhQiA2oiCEkgCCAKa0EBRnENBiADIAdPBEAgASAHNgIUCyACIAlJDQEgASAJNgIgIAkhAgwBCyACIANNDQUgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBEzoAACABIAJBAWo2AiAgAS0AWCEDDAMLIAIgCE0NASABIAI2AlRBACECIAFBADYCICABQQA2AhQLIAEoAgwgAkYEQCABQQxqQYCEwAAQUgsgASgCECACakETOgAAIAEgAkEBajYCFCABLQBYIQMLIANB/wFxQQJHDQEgAS0AWUUNASABKAIIIAZJDQEgASAGNgIIDAELQQAhBSADQf8BcUECRw0AIAEtAFlFDQAgBiABKAIIIgJPDQEgASgCBCAGQQxsaiIDLQAADQIgAyACNgIEIAEoAlAhByABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIDIAc2AgggAyAGNgIEIANBgSY7AQAgASACQQFqNgIICyAAIAE2AgQgACAFNgIAIARBMGokAA8LIAYgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAu3BwELfyMAQRBrIgwkAAJAIAFBAk8EQAJ/AkAgAyABQRBqTwRAIAFBAXYhCiABQQ9LDQEgAUEHSwRAIAIgAEECQQMgAC0AAyAALQACSSIHG2oiCC0AACIDIAAgAC0AASIGIAAtAAAiCU9qIgQtAAAiBSADIAVLGzoAAyACIABBA0ECIAcbaiIHLQAAIgsgACAGIAlJaiIJLQAAIgYgBiALSyIGGzoAACACIAggBCAHIAYbIAMgBUkiBRstAAAiAyAJIAcgBCAFGyAGGy0AACIEIAMgBEsbOgACIAIgAyAEIAMgBEkbOgABIAIgCmoiBCAAIApqIgNBAkEDIAMtAAMgAy0AAkkiCBtqIgstAAAiBSADIAMtAAEiCSADLQAAIg1PaiIHLQAAIgYgBSAGSxs6AAMgBCADQQNBAiAIG2oiCC0AACIOIAMgCSANSWoiDS0AACIDIAMgDksiCRs6AAAgBCALIAcgCCAJGyAFIAZJIgUbLQAAIgMgDSAIIAcgBRsgCRstAAAiBSADIAVJGzoAASAEIAMgBSADIAVLGzoAAkEEDAMLIAIgAC0AADoAACACIApqIAAgCmotAAA6AABBAQwCCwALIAAgAiABIAJqIgMQHSAAIApqIAIgCmogA0EIahAdQQgLIQUgDEECNgIMIAwgCq1CIIY3AwAgASAKayEJQQAhA0ECIQcDQCAMIANBAWoiBDYCCCADQQJ0IQYgBCEDIAkgCiAGIAxqKAIAIgQbIgsgBUsEQCACIARqIQYgACAEaiENIAUhBANAIAQgBmoiAyAEIA1qLQAAIgg6AAAgA0EBay0AACIHIAhLBEAgBCEDAn8DQCADIAZqIg4gBzoAACAGIANBAUYNARogA0EBayEDIAggDkECay0AACIHSQ0ACyADIAZqCyAIOgAACyAEQQFqIgQgC0cNAAsgDCgCDCEHIAwoAgghAwsgAyAHRw0ACyAAIAFBAWsiA2ohBCACIANqIQUgAiAKaiIDQQFrIQcDQCAAIAMtAAAiCSACLQAAIgsgCSALSSINGzoAACAEIAUtAAAiBiAHLQAAIgggBiAISxs6AAAgBEEBayEEIABBAWohACAHIAYgCElrIQcgBSAGIAhPayEFIAIgCSALT2ohAiADIA1qIQMgCkEBayIKDQALIAdBAWohBCABQQFxBH8gACACIAMgAiAESSIAGy0AADoAACADIAIgBE9qIQMgACACagUgAgsgBEcgAyAFQQFqR3INAQsgDEEQaiQADwsQgQEAC8UHAQ1/IAEoAlAiAiABKAJUIgZGBEAgASgCICEJIAEoAhQhBwsgASgCCCEFAkAgAS0AWEECRwRAIAUhAwwBCyAFIQMgAS0AWUUNACABKAIAIANGBEAgAUGYg8AAEEwLIAEoAgQgBUEMbGoiAyACNgIIIANBADYCBCADQQA6AAAgASAFQQFqIgM2AgggASgCVCEGCyACIAZGBEAgASgCICABKAIUaiEKC0EBIQsCQAJAIAEoAlAiBCABKAJMIgxPDQAgASgCSCINIARqLQAAQSBHDQAgBEECaiIIIARBAWoiDkkgCCAMS3INACANIA5qLQAAQSBHDQAgASAINgJQQQAhCyAIIAxPDQEgCCANai0AAEEgRw0BIAEgBEEDaiIINgJQIAggDE8NACAIIA1qLQAAQSBHDQAgBEEEaiEEA0AgASAENgJQIAQgDEYNASAEIA1qIARBAWohBC0AAEEgRg0ACwsgASADNgIICyABLQBYIQMCQAJAAkACQAJAIAtFBEAgA0H/AXFBAUcNASABLQBZRQ0DAkAgAiAGRgRAIAogASgCICICIAEoAhQiA2oiBkkgBiAKa0EBRnENBSADIAdPBEAgASAHNgIUCyACIAlJDQEgASAJNgIgIAkhAgwBCyACIAZNDQQgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBBToAACABIAJBAWo2AiAgAS0AWCEDDAELIANB/wFxQQFGDQICQCABLQBZRQ0AAkAgAiAGRgRAIAogASgCICIGIAEoAhQiAmoiBEkgBCAKa0EBRnENAiACIAdPBEAgASAHNgIUIAchAgsgBiAJSQ0BIAEgCTYCIAwBCyACIAZNDQEgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIMIAJGBEAgAUEMakGAhMAAEFILIAEoAhAgAmpBBToAACABIAJBAWo2AhQgAS0AWCEDCyADQf8BcUECRw0CIAEtAFlFDQIgASgCCCAFTw0BDAILIANB/wFxQQJHDQEgAS0AWUUNASAFIAEoAggiAk8NAiABKAIEIAVBDGxqIgMtAAANAyADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAU2AgQgA0GBCjsBACACQQFqIQULIAEgBTYCCAsgACABNgIEIAAgCzYCAA8LIAUgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAvIBwELfyABKAJQIgUgASgCVCIHRgRAIAEoAiAhCSABKAIUIQQLIAEoAgghBgJAIAEtAFhBAkcEQCAGIQIMAQsgBiECIAEtAFlFDQAgASgCACACRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgIgBTYCCCACQQA2AgQgAkEAOgAAIAEgBkEBaiICNgIIIAEoAlQhBwsgBSAHRgRAIAEoAiAgASgCFGohCgsgASgCTCEIIAEoAkghCwJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAIAEoAlAiA0F7Sw0AIANBBGoiDCAISw0AIAMgC2ooAABB6OjRgwdHDQAgASAMNgJQIANBBWoiAyAMSSADIAhLcg0CIAsgDGotAABB8wBGDQEMAgsgASACNgIIIANBfEsNAiADQQNqIgIgCEsNAkGVhcAAIAMgC2pBAxByDQIgA0EGaiIDIAJJIAMgCEtyDQJBmIXAACACIAtqQQMQcg0CCyABIAM2AlALIAEtAFgiCEEBRg0BDAULQQEhAyABLQBYIghBAUYNBiABLQBZRQ0DIAUgB0cNASAKIAEoAiAiBSABKAIUIgJqIgdJIAcgCmtBAUZxDQMgAiAETwRAIAEgBDYCFCAEIQILIAUgCUkNAiABIAk2AiAMAgtBACEDIAEtAFlFDQUCQCAFIAdGBEAgCiABKAIgIgIgASgCFCIFaiIHSSAHIAprQQFGcQ0HIAQgBU0EQCABIAQ2AhQLIAIgCUkNASABIAk2AiAgCSECDAELIAUgB00NBiABIAU2AlRBACECIAFBADYCICABQQA2AhQLIAEoAhggAkYEQCABQRhqQYCEwAAQUgsgASgCHCACakEROgAAIAEgAkEBajYCICABLQBYIQgMAwsgBSAHTQ0BIAEgBTYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQRE6AAAgASACQQFqNgIUIAEtAFghCAsgCEECRw0CIAEtAFlFDQJBASABKAIIIAZPDQEaDAILQQAhAyAIQQJHDQEgAS0AWUUNASAGIAEoAggiAk8NAiABKAIEIAZBDGxqIgQtAAANAyAEIAI2AgQgASgCUCEJIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgQgCTYCCCAEIAY2AgQgBEGBIjsBACACQQFqIQZBAAshAyABIAY2AggLIAAgATYCBCAAIAM2AgAPCyAGIAJBqIPAABBpAAtByIPAAEEoQfCDwAAQewALxgYBCH8CQAJAIAEgAEEDakF8cSIDIABrIghJDQAgASAIayIGQQRJDQAgBkEDcSEHQQAhAQJAIAAgA0YiCQ0AAkAgACADayIFQXxLBEBBACEDDAELQQAhAwNAIAEgACADaiICLAAAQb9/SmogAkEBaiwAAEG/f0pqIAJBAmosAABBv39KaiACQQNqLAAAQb9/SmohASADQQRqIgMNAAsLIAkNACAAIANqIQIDQCABIAIsAABBv39KaiEBIAJBAWohAiAFQQFqIgUNAAsLIAAgCGohAAJAIAdFDQAgACAGQXxxaiIDLAAAQb9/SiEEIAdBAUYNACAEIAMsAAFBv39KaiEEIAdBAkYNACAEIAMsAAJBv39KaiEECyAGQQJ2IQUgASAEaiEEA0AgACEDIAVFDQJBwAEgBSAFQcABTxsiBkEDcSEHIAZBAnQhCEEAIQIgBUEETwRAIAAgCEHwB3FqIQkgACEBA0AgASgCACIAQX9zQQd2IABBBnZyQYGChAhxIAJqIAEoAgQiAEF/c0EHdiAAQQZ2ckGBgoQIcWogASgCCCIAQX9zQQd2IABBBnZyQYGChAhxaiABKAIMIgBBf3NBB3YgAEEGdnJBgYKECHFqIQIgAUEQaiIBIAlHDQALCyAFIAZrIQUgAyAIaiEAIAJBCHZB/4H8B3EgAkH/gfwHcWpBgYAEbEEQdiAEaiEEIAdFDQALAn8gAyAGQfwBcUECdGoiACgCACIBQX9zQQd2IAFBBnZyQYGChAhxIgEgB0EBRg0AGiABIAAoAgQiAUF/c0EHdiABQQZ2ckGBgoQIcWoiASAHQQJGDQAaIAAoAggiAEF/c0EHdiAAQQZ2ckGBgoQIcSABagsiAUEIdkH/gRxxIAFB/4H8B3FqQYGABGxBEHYgBGoPCyABRQRAQQAPCyABQQNxIQMCQCABQQRJBEAMAQsgAUF8cSEFA0AgBCAAIAJqIgEsAABBv39KaiABQQFqLAAAQb9/SmogAUECaiwAAEG/f0pqIAFBA2osAABBv39KaiEEIAUgAkEEaiICRw0ACwsgA0UNACAAIAJqIQEDQCAEIAEsAABBv39KaiEEIAFBAWohASADQQFrIgMNAAsLIAQLzgYBDn8jAEEQayIGJABBASEMAkAgAigCHCIJQSIgAigCICINKAIQIg4RAQANAAJAIAFFBEBBACECDAELQQAgAWshDyAAIQcgASEDAkACfwJAAkADQCADIAdqIRBBACECAkADQCACIAdqIgotAAAiBUH/AGtB/wFxQaEBSSAFQSJGciAFQdwARnINASADIAJBAWoiAkcNAAsgAyAIagwECyAKQQFqIQcCQCAKLAAAIgtBAE4EQCALQf8BcSEDDAELIActAABBP3EhAyALQR9xIQUgCkECaiEHIAtBX00EQCAFQQZ0IANyIQMMAQsgBy0AAEE/cSADQQZ0ciEDIApBA2ohByALQXBJBEAgAyAFQQx0ciEDDAELIAVBEnRBgIDwAHEgBy0AAEE/cSADQQZ0cnIhAyAKQQRqIQcLIAZBBGogA0GBgAQQIQJAAkAgBi0ABEGAAUYNACAGLQAPIAYtAA5rQf8BcUEBRg0AIAQgAiAIaiIFSw0BAkAgBEUNACABIARNBEAgASAERw0DDAELIAAgBGosAABBv39MDQILAkAgBUUNACABIAVNBEAgBSAPakUNAQwDCyAAIAhqIAJqLAAAQb9/TA0CCyAJIAAgBGogCCAEayACaiANKAIMIgURAgANAwJAIAYtAARBgAFGBEAgCSAGKAIIIA4RAQBFDQEMBQsgCSAGLQAOIgQgBkEEamogBi0ADyAEayAFEQIADQQLAn9BASADQYABSQ0AGkECIANBgBBJDQAaQQNBBCADQYCABEkbCyAIaiACaiEECwJ/QQEgA0GAAUkNABpBAiADQYAQSQ0AGkEDQQQgA0GAgARJGwsgCGoiBSACaiEIIBAgB2siA0UNAwwBCwsgACABIAQgBUGcssAAEJsBAAsMBAsgAiAFagsiAiAESQ0AQQAhAwJAIARFDQAgASAETQRAIAQiAyABRw0CDAELIAQiAyAAaiwAAEG/f0wNAQsgAkUEQEEAIQIMAgsgASACTQRAIAMhBCABIAJGDQIMAQsgAyEEIAAgAmosAABBv39KDQELIAAgASAEIAJBrLLAABCbAQALIAkgACADaiACIANrIA0oAgwRAgANACAJQSIgDhEBACEMCyAGQRBqJAAgDAuTBwEJfyABKAJQIgIgASgCVCIDRgRAIAEoAiAhCCABKAIUIQULIAEoAgghBgJAIAEtAFhBAkcNACABLQBZRQ0AIAEoAgAgBkYEQCABQZiDwAAQTAsgASgCBCAGQQxsaiIDIAI2AgggA0EANgIEIANBADoAACABIAZBAWo2AgggASgCVCEDCyACIANGBEAgASgCICABKAIUaiEJCwJAAkACQAJ/AkACQAJAAkACQAJAIAEoAlAiB0F8Sw0AIAdBA2oiCiABKAJMSw0AAkBBgIXAACABKAJIIAdqIgRBAxByRQ0AQYOFwAAgBEEDEHJFDQBBhoXAACAEQQMQckUNAEGJhcAAIARBAxByRQ0AQYyFwAAgBEEDEHJFDQBBj4XAACAEQQMQckUNAEGShcAAIAEoAkggB2pBAxByDQELIAEgCjYCUCABLQBYIgRBAUYNAQwFC0EBIQcgAS0AWCIEQQFGDQYgAS0AWUUNAyACIANHDQEgCSABKAIgIgMgASgCFCICaiIKSSAKIAlrQQFGcQ0DIAIgBU8EQCABIAU2AhQgBSECCyADIAhJDQIgASAINgIgDAILQQAhByABLQBZRQ0FAkAgAiADRgRAIAkgASgCICICIAEoAhQiA2oiBEkgBCAJa0EBRnENByADIAVPBEAgASAFNgIUCyACIAhJDQEgASAINgIgIAghAgwBCyACIANNDQYgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBBjoAACABIAJBAWo2AiAgAS0AWCEEDAMLIAIgA00NASABIAI2AlRBACECIAFBADYCICABQQA2AhQLIAEoAgwgAkYEQCABQQxqQYCEwAAQUgsgASgCECACakEGOgAAIAEgAkEBajYCFCABLQBYIQQLIARBAkcNAiABLQBZRQ0CQQEgASgCCCAGTw0BGgwCC0EAIQcgBEECRw0BIAEtAFlFDQEgBiABKAIIIgJPDQIgASgCBCAGQQxsaiIFLQAADQMgBSACNgIEIAEoAlAhCCABKAIIIgIgASgCAEYEQCABQbiDwAAQTAsgASgCBCACQQxsaiIFIAg2AgggBSAGNgIEIAVBgQw7AQAgAkEBaiEGQQALIQcgASAGNgIICyAAIAE2AgQgACAHNgIADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC8kGAQp/IwBBEGsiCCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEHIAEoAhQhAwsgASgCCCEGAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgBkEBajYCCCABKAJUIQULIAIgBUYEQCABKAIgIAEoAhRqIQkLAkAgAS0AWSIERQRAIAggARA9IAgoAgQhASAIKAIAIQUMAQsgAUEAOgBZIAhBCGogARA9IAgoAgghBSAIKAIMIgEgBDoAWQsgAS0AWCEEAkACQAJAAkAgBUUEQCAEQQFHDQEgAS0AWUUNAgJAIAIgASgCVCIERgRAIAkgASgCICICIAEoAhQiBGoiCkkgCiAJa0EBRnENBCADIARNBEAgASADNgIUCyACIAdJDQEgASAHNgIgIAchAgwBCyACIARNDQMgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBDjoAACABIAJBAWo2AiAgAS0AWCEEDAELIARBAUYNAQJAIAEtAFlFDQACQCACIAEoAlQiCkYEQCAJIAEoAiAiCiABKAIUIgJqIgtJIAsgCWtBAUZxDQIgAiADTwRAIAEgAzYCFCADIQILIAcgCksNASABIAc2AiAMAQsgAiAKTQ0BIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQQ46AAAgASACQQFqNgIUIAEtAFghBAsgBEECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyAEQQJHDQAgAS0AWUUNACAGIAEoAggiAk8NASABKAIEIAZBDGxqIgMtAAANAiADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAY2AgQgA0GBHDsBACABIAJBAWo2AggLIAAgATYCBCAAIAVBAEc2AgAgCEEQaiQADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC8kGAQp/IwBBEGsiCCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEHIAEoAhQhAwsgASgCCCEGAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgBkEBajYCCCABKAJUIQULIAIgBUYEQCABKAIgIAEoAhRqIQkLAkAgAS0AWSIERQRAIAggARA7IAgoAgQhASAIKAIAIQUMAQsgAUEAOgBZIAhBCGogARA7IAgoAgghBSAIKAIMIgEgBDoAWQsgAS0AWCEEAkACQAJAAkAgBUUEQCAEQQFHDQEgAS0AWUUNAgJAIAIgASgCVCIERgRAIAkgASgCICICIAEoAhQiBGoiCkkgCiAJa0EBRnENBCADIARNBEAgASADNgIUCyACIAdJDQEgASAHNgIgIAchAgwBCyACIARNDQMgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBEDoAACABIAJBAWo2AiAgAS0AWCEEDAELIARBAUYNAQJAIAEtAFlFDQACQCACIAEoAlQiCkYEQCAJIAEoAiAiCiABKAIUIgJqIgtJIAsgCWtBAUZxDQIgAiADTwRAIAEgAzYCFCADIQILIAcgCksNASABIAc2AiAMAQsgAiAKTQ0BIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQRA6AAAgASACQQFqNgIUIAEtAFghBAsgBEECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyAEQQJHDQAgAS0AWUUNACAGIAEoAggiAk8NASABKAIEIAZBDGxqIgMtAAANAiADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAY2AgQgA0GBIDsBACABIAJBAWo2AggLIAAgATYCBCAAIAVBAEc2AgAgCEEQaiQADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC8kGAQp/IwBBEGsiCCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEHIAEoAhQhAwsgASgCCCEGAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgBkEBajYCCCABKAJUIQULIAIgBUYEQCABKAIgIAEoAhRqIQkLAkAgAS0AWSIERQRAIAggARBAIAgoAgQhASAIKAIAIQUMAQsgAUEAOgBZIAhBCGogARBAIAgoAgghBSAIKAIMIgEgBDoAWQsgAS0AWCEEAkACQAJAAkAgBUUEQCAEQQFHDQEgAS0AWUUNAgJAIAIgASgCVCIERgRAIAkgASgCICICIAEoAhQiBGoiCkkgCiAJa0EBRnENBCADIARNBEAgASADNgIUCyACIAdJDQEgASAHNgIgIAchAgwBCyACIARNDQMgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBFjoAACABIAJBAWo2AiAgAS0AWCEEDAELIARBAUYNAQJAIAEtAFlFDQACQCACIAEoAlQiCkYEQCAJIAEoAiAiCiABKAIUIgJqIgtJIAsgCWtBAUZxDQIgAiADTwRAIAEgAzYCFCADIQILIAcgCksNASABIAc2AiAMAQsgAiAKTQ0BIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQRY6AAAgASACQQFqNgIUIAEtAFghBAsgBEECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyAEQQJHDQAgAS0AWUUNACAGIAEoAggiAk8NASABKAIEIAZBDGxqIgMtAAANAiADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAY2AgQgA0GBLDsBACABIAJBAWo2AggLIAAgATYCBCAAIAVBAEc2AgAgCEEQaiQADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC8kGAQp/IwBBEGsiCCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEHIAEoAhQhAwsgASgCCCEGAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgBkEBajYCCCABKAJUIQULIAIgBUYEQCABKAIgIAEoAhRqIQkLAkAgAS0AWSIERQRAIAggARAEIAgoAgQhASAIKAIAIQUMAQsgAUEAOgBZIAhBCGogARAEIAgoAgghBSAIKAIMIgEgBDoAWQsgAS0AWCEEAkACQAJAAkAgBUUEQCAEQQFHDQEgAS0AWUUNAgJAIAIgASgCVCIERgRAIAkgASgCICICIAEoAhQiBGoiCkkgCiAJa0EBRnENBCADIARNBEAgASADNgIUCyACIAdJDQEgASAHNgIgIAchAgwBCyACIARNDQMgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBBDoAACABIAJBAWo2AiAgAS0AWCEEDAELIARBAUYNAQJAIAEtAFlFDQACQCACIAEoAlQiCkYEQCAJIAEoAiAiCiABKAIUIgJqIgtJIAsgCWtBAUZxDQIgAiADTwRAIAEgAzYCFCADIQILIAcgCksNASABIAc2AiAMAQsgAiAKTQ0BIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQQQ6AAAgASACQQFqNgIUIAEtAFghBAsgBEECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyAEQQJHDQAgAS0AWUUNACAGIAEoAggiAk8NASABKAIEIAZBDGxqIgMtAAANAiADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAY2AgQgA0GBCDsBACABIAJBAWo2AggLIAAgATYCBCAAIAVBAEc2AgAgCEEQaiQADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC8kGAQp/IwBBEGsiCCQAIAEoAlAiAiABKAJUIgVGBEAgASgCICEHIAEoAhQhAwsgASgCCCEGAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAGRgRAIAFBmIPAABBMCyABKAIEIAZBDGxqIgUgAjYCCCAFQQA2AgQgBUEAOgAAIAEgBkEBajYCCCABKAJUIQULIAIgBUYEQCABKAIgIAEoAhRqIQkLAkAgAS0AWSIERQRAIAggARAmIAgoAgQhASAIKAIAIQUMAQsgAUEAOgBZIAhBCGogARAmIAgoAgghBSAIKAIMIgEgBDoAWQsgAS0AWCEEAkACQAJAAkAgBUUEQCAEQQFHDQEgAS0AWUUNAgJAIAIgASgCVCIERgRAIAkgASgCICICIAEoAhQiBGoiCkkgCiAJa0EBRnENBCADIARNBEAgASADNgIUCyACIAdJDQEgASAHNgIgIAchAgwBCyACIARNDQMgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBCjoAACABIAJBAWo2AiAgAS0AWCEEDAELIARBAUYNAQJAIAEtAFlFDQACQCACIAEoAlQiCkYEQCAJIAEoAiAiCiABKAIUIgJqIgtJIAsgCWtBAUZxDQIgAiADTwRAIAEgAzYCFCADIQILIAcgCksNASABIAc2AiAMAQsgAiAKTQ0BIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCDCACRgRAIAFBDGpBgITAABBSCyABKAIQIAJqQQo6AAAgASACQQFqNgIUIAEtAFghBAsgBEECRw0BIAEtAFlFDQEgASgCCCAGSQ0BIAEgBjYCCAwBCyAEQQJHDQAgAS0AWUUNACAGIAEoAggiAk8NASABKAIEIAZBDGxqIgMtAAANAiADIAI2AgQgASgCUCEHIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgMgBzYCCCADIAY2AgQgA0GBFDsBACABIAJBAWo2AggLIAAgATYCBCAAIAVBAEc2AgAgCEEQaiQADwsgBiACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC7sGAQl/IAEoAlAiAiABKAJUIgNGBEAgASgCICEHIAEoAhQhBAsgASgCCCEFAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAFRgRAIAFBmIPAABBMCyABKAIEIAVBDGxqIgMgAjYCCCADQQA2AgQgA0EAOgAAIAEgBUEBajYCCCABKAJUIQMLIAIgA0YEQCABKAIgIAEoAhRqIQgLQQEhCQJAAkACQAJ/AkACQAJAAkACQAJAIAEoAlAiBiABKAJMTw0AIAEoAkggBmotAABBIWsiCkEeS0EBIAp0QYHQgLAEcUVyDQAgASAGQQFqNgJQIAEtAFgiBkEBRg0BDAULIAEtAFgiBkEBRg0GIAEtAFlFDQMgAiADRw0BIAggASgCICIDIAEoAhQiAmoiCkkgCiAIa0EBRnENAyACIARPBEAgASAENgIUIAQhAgsgAyAHSQ0CIAEgBzYCIAwCC0EAIQkgAS0AWUUNBQJAIAIgA0YEQCAIIAEoAiAiAiABKAIUIgNqIgZJIAYgCGtBAUZxDQcgAyAETwRAIAEgBDYCFAsgAiAHSQ0BIAEgBzYCICAHIQIMAQsgAiADTQ0GIAEgAjYCVEEAIQIgAUEANgIgIAFBADYCFAsgASgCGCACRgRAIAFBGGpBgITAABBSCyABKAIcIAJqQQc6AAAgASACQQFqNgIgIAEtAFghBgwDCyACIANNDQEgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIMIAJGBEAgAUEMakGAhMAAEFILIAEoAhAgAmpBBzoAACABIAJBAWo2AhQgAS0AWCEGCyAGQQJHDQIgAS0AWUUNAkEBIAEoAgggBU8NARoMAgtBACEJIAZBAkcNASABLQBZRQ0BIAUgASgCCCICTw0CIAEoAgQgBUEMbGoiBC0AAA0DIAQgAjYCBCABKAJQIQcgASgCCCICIAEoAgBGBEAgAUG4g8AAEEwLIAEoAgQgAkEMbGoiBCAHNgIIIAQgBTYCBCAEQYEOOwEAIAJBAWohBUEACyEJIAEgBTYCCAsgACABNgIEIAAgCTYCAA8LIAUgAkGog8AAEGkAC0HIg8AAQShB8IPAABB7AAuuBQEHfwJAIAAoAgAiCSAAKAIIIgRyBEACQCAEQQFxRQ0AIAEgAmohBwJAIAAoAgwiBkUEQCABIQQMAQsgASEEA0AgBCIDIAdGDQICfyADQQFqIAMsAAAiCEEATg0AGiADQQJqIAhBYEkNABogA0EDaiAIQXBJDQAaIANBBGoLIgQgA2sgBWohBSAGQQFrIgYNAAsLIAQgB0YNACAELAAAGiAFIAICfwJAIAVFDQAgAiAFTQRAIAIgBUYNAUEADAILIAEgBWosAABBQE4NAEEADAELIAELIgMbIQIgAyABIAMbIQELIAlFDQEgACgCBCEHAkAgAkEQTwRAIAEgAhATIQMMAQsgAkUEQEEAIQMMAQsgAkEDcSEGAkAgAkEESQRAQQAhA0EAIQUMAQsgAkEMcSEIQQAhA0EAIQUDQCADIAEgBWoiBCwAAEG/f0pqIARBAWosAABBv39KaiAEQQJqLAAAQb9/SmogBEEDaiwAAEG/f0pqIQMgCCAFQQRqIgVHDQALCyAGRQ0AIAEgBWohBANAIAMgBCwAAEG/f0pqIQMgBEEBaiEEIAZBAWsiBg0ACwsCQCADIAdJBEAgByADayEGAkACQAJAIAAtABgiBEEAIARBA0cbIgNBAWsOAgABAgsgBiEDQQAhBgwBCyAGQQF2IQMgBkEBakEBdiEGCyADQQFqIQMgACgCECEFIAAoAiAhBCAAKAIcIQADQCADQQFrIgNFDQIgACAFIAQoAhARAQBFDQALQQEPCwwCCyAAIAEgAiAEKAIMEQIABEBBAQ8LQQAhAwNAIAMgBkYEQEEADwsgA0EBaiEDIAAgBSAEKAIQEQEARQ0ACyADQQFrIAZJDwsgACgCHCABIAIgACgCICgCDBECAA8LIAAoAhwgASACIAAoAiAoAgwRAgAL1QUBDX8gACAALQABIgYgAC0AACIDSWoiBSAAQQNBAiAALQADIAAtAAJJIgQbaiIHIAAgAyAGTWoiBiAAQQJBAyAEG2oiAy0AACAGLQAASSIEGyAHLQAAIgogBS0AACILSSIFGyIILQAAIQwgAyAGIAcgBRsgBBsiCS0AACENIAIgCiALIAUbIgc6AAAgAiAJIAggDCANSyIFGy0AADoAASACIAggCSAFGy0AADoAAiACQQNqIgogBiADIAQbLQAAIgY6AAAgAEEEaiIDIAAtAAUiBSAALQAEIghJaiIJIANBA0ECIAAtAAcgAC0ABkkiCxtqIgQgAyAFIAhPaiIAIANBAkEDIAsbaiIFLQAAIAAtAABJIggbIAQtAAAiCyAJLQAAIgxJIgMbIgktAAAhDSAFIAAgBCADGyAIGyIELQAAIQ4gAkEEaiIPIAsgDCADGyIDOgAAIAJBBWogBCAJIA0gDksiCxstAAA6AAAgAkEGaiAJIAQgCxstAAA6AAAgAkEHaiIJIAAgBSAIGy0AACIAOgAAIAEgAyAHIAMgB0kiBBs6AAAgASAAIAYgACAGSxs6AAcgASAEIA9qIgUtAAAiBCACIAMgB09qIggtAAAiByAEIAdJIgMbOgABIAEgCSAAIAZPayIJLQAAIgIgCiAAIAZJayIKLQAAIgAgACACSRs6AAYgASADIAVqIgUtAAAiAyAIIAQgB09qIgQtAAAiByADIAdJIggbOgACIAEgCSAAIAJNayIJLQAAIgYgCiAAIAJLayIKLQAAIgAgACAGSRs6AAUgASAFIAhqIgUtAAAiAiAEIAMgB09qIgMtAAAiByACIAdJIgQbOgADIAEgCSAAIAZNayIILQAAIgEgCiAAIAZLayIGLQAAIgAgACABSRs6AAQgAyACIAdPaiAGIAAgAUtrQQFqRiAEIAVqIAggACABTWtBAWpGcUUEQBCBAQALC8gFAQh/QStBgIDEACAAKAIUIghBAXEiBhshDCAEIAZqIQYCQCAIQQRxRQRAQQAhAQwBCwJAIAJBEE8EQCABIAIQEyEFDAELIAJFBEAMAQsgAkEDcSEJAkAgAkEESQRADAELIAJBDHEhCgNAIAUgASAHaiILLAAAQb9/SmogC0EBaiwAAEG/f0pqIAtBAmosAABBv39KaiALQQNqLAAAQb9/SmohBSAKIAdBBGoiB0cNAAsLIAlFDQAgASAHaiEHA0AgBSAHLAAAQb9/SmohBSAHQQFqIQcgCUEBayIJDQALCyAFIAZqIQYLIAAoAgBFBEAgACgCHCIGIAAoAiAiACAMIAEgAhB/BEBBAQ8LIAYgAyAEIAAoAgwRAgAPCwJAAkACQCAGIAAoAgQiB08EQCAAKAIcIgYgACgCICIAIAwgASACEH9FDQFBAQ8LIAhBCHFFDQEgACgCECEIIABBMDYCECAALQAYIQpBASEFIABBAToAGCAAKAIcIgkgACgCICILIAwgASACEH8NAiAHIAZrQQFqIQUCQANAIAVBAWsiBUUNASAJQTAgCygCEBEBAEUNAAtBAQ8LIAkgAyAEIAsoAgwRAgAEQEEBDwsgACAKOgAYIAAgCDYCEEEADwsgBiADIAQgACgCDBECACEFDAELIAcgBmshBgJAAkACQEEBIAAtABgiBSAFQQNGGyIFQQFrDgIAAQILIAYhBUEAIQYMAQsgBkEBdiEFIAZBAWpBAXYhBgsgBUEBaiEFIAAoAhAhCiAAKAIgIQggACgCHCEAAkADQCAFQQFrIgVFDQEgACAKIAgoAhARAQBFDQALQQEPC0EBIQUgACAIIAwgASACEH8NACAAIAMgBCAIKAIMEQIADQBBACEFA0AgBSAGRgRAQQAPCyAFQQFqIQUgACAKIAgoAhARAQBFDQALIAVBAWsgBkkPCyAFC+8FAQl/IAEoAlAiAiABKAJUIgNGBEAgASgCICEGIAEoAhQhBAsgASgCCCEFAkAgAS0AWEECRw0AIAEtAFlFDQAgASgCACAFRgRAIAFBmIPAABBMCyABKAIEIAVBDGxqIgMgAjYCCCADQQA2AgQgA0EAOgAAIAEgBUEBajYCCCABKAJUIQMLIAIgA0YEQCABKAIgIAEoAhRqIQgLIAEtAFghBwJAAkACQAJAAkAgASgCUCABKAJMRyIJRQRAIAdBAUcNASABLQBZRQ0DAkAgAiADRgRAIAggASgCICICIAEoAhQiA2oiB0kgByAIa0EBRnENBSADIARPBEAgASAENgIUCyACIAZJDQEgASAGNgIgIAYhAgwBCyACIANNDQQgASACNgJUQQAhAiABQQA2AiAgAUEANgIUCyABKAIYIAJGBEAgAUEYakGAhMAAEFILIAEoAhwgAmpBADoAACABIAJBAWo2AiAgAS0AWCEHDAELIAdBAUYNAgJAIAEtAFlFDQACQCACIANGBEAgCCABKAIgIgMgASgCFCICaiIKSSAKIAhrQQFGcQ0CIAIgBE8EQCABIAQ2AhQgBCECCyADIAZJDQEgASAGNgIgDAELIAIgA00NASABIAI2AlRBACECIAFBADYCICABQQA2AhQLIAEoAgwgAkYEQCABQQxqQYCEwAAQUgsgASgCECACakEAOgAAIAEgAkEBajYCFCABLQBYIQcLIAdBAkcNAiABLQBZRQ0CIAEoAgggBU8NAQwCCyAHQQJHDQEgAS0AWUUNASAFIAEoAggiAk8NAiABKAIEIAVBDGxqIgQtAAANAyAEIAI2AgQgASgCUCEGIAEoAggiAiABKAIARgRAIAFBuIPAABBMCyABKAIEIAJBDGxqIgQgBjYCCCAEIAU2AgQgBEEBOwEAIAJBAWohBQsgASAFNgIICyAAIAE2AgQgACAJNgIADwsgBSACQaiDwAAQaQALQciDwABBKEHwg8AAEHsAC9wFAQt/IAEgAS0AWCIJQQFHOgBYIAEoAiwhAyABKAJQIQcgASgCTCEFIAEoAkghCCABKAIIIQogASgCRCICIAEoAjxGBEAgAUE8akHwkcAAEFALIAEoAkAgAkECdGogAzYCACABIAJBAWo2AkQCQAJAAkACQCABKAI4IgIEQCABKAI0IAJBBHRqIgJBDGsoAgAhBCACQRBrKAIAIQYgAkEEaygCACIDIAJBCGsoAgAiAkkNAyACRQ0CIAIgBEkNASACIARHDQMMAgtBgIDAAEEeQYCBwAAQbgALIAIgBmosAABBv39MDQELAkAgA0UNACADIARPBEAgAyAERg0BDAILIAMgBmosAABBv39MDQELIAFBJGohBAJAAkACQAJAIAEoAlAiCyADIAJrIgNqIgwgC0kNACAMIAEoAkxLDQAgAiAGaiABKAJIIAtqIAMQckUNAQsgASAJOgBYIAEgBzYCUCABIAU2AkwgASAINgJIIAQQQyABKAJMIQMgASgCSCEEAkAgASgCUCICRQ0AIAIgA08EQCACIANGDQEMBgsgAiAEaiwAAEG/f0wNBQsgAiADRg0BQQEhBgJAIAIgBGoiAywAACIEQQBODQAgAy0AAUE/cSEFIARBH3EhBwJ/IAdBBnQgBXIgBEFgSQ0AGiADLQACQT9xIAVBBnRyIQUgBSAHQQx0ciAEQXBJDQAaIAdBEnRBgIDwAHEgAy0AA0E/cSAFQQZ0cnILIgNBgAFJDQBBAiEGIANBgBBJDQBBA0EEIANBgIAESRshBgsgASACIAZqNgJQQQAhAgwCCyABIAk6AFggASAHNgJQIAEgBTYCTCABIAg2AkggBBBDCyABIAc2AlAgASAFNgJMIAEgCDYCSEEBIQIgASgCCCAKSQ0AIAEgCjYCCAsgACABNgIEIAAgAjYCAA8LIAYgBCACIANB6IHAABCbAQALIAQgAyACIANB8ITAABCbAQALuAsBBX8jAEEgayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4oBgEBAQEBAQEBAgQBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQgBAQEBBwALIAFB3ABGDQQLIAJBAXFFIAFBgAZJcg0HAn8CQEERQQAgAUGvsARPGyICIAJBCHIiAyABQQt0IgIgA0ECdEGww8AAaigCAEELdEkbIgMgA0EEciIDIANBAnRBsMPAAGooAgBBC3QgAksbIgMgA0ECciIDIANBAnRBsMPAAGooAgBBC3QgAksbIgMgA0EBaiIDIANBAnRBsMPAAGooAgBBC3QgAksbIgMgA0EBaiIDIANBAnRBsMPAAGooAgBBC3QgAksbIgNBAnRBsMPAAGooAgBBC3QiBSACRiACIAVLaiADaiIDQSFNBEAgA0ECdEGww8AAaiIGKAIAQRV2IQJB7wUhBQJ/AkAgA0EhRg0AIAYoAgRBFXYhBSADDQBBAAwBCyAGQQRrKAIAQf///wBxCyEDAkAgBSACQX9zakUNACABIANrIQdB7wUgAiACQe8FTRshBiAFQQFrIQNBACEFA0AgAiAGRg0DIAUgAkG4xMAAai0AAGoiBSAHSw0BIAMgAkEBaiICRw0ACyADIQILIAJBAXEMAgsgA0EiQfjBwAAQaQALIAZB7wVBiMLAABBpAAtFDQcgBEEAOgAKIARBADsBCCAEIAFBFHZBq63AAGotAAA6AAsgBCABQQR2QQ9xQautwABqLQAAOgAPIAQgAUEIdkEPcUGrrcAAai0AADoADiAEIAFBDHZBD3FBq63AAGotAAA6AA0gBCABQRB2QQ9xQautwABqLQAAOgAMIAFBAXJnQQJ2IgIgBEEIaiIDaiIFQfsAOgAAIAVBAWtB9QA6AAAgAyACQQJrIgJqQdwAOgAAIARBEGoiAyABQQ9xQautwABqLQAAOgAAIABBCjoACyAAIAI6AAogACAEKQIINwIAIARB/QA6ABEgAEEIaiADLwEAOwEADAkLIABBgAQ7AQogAEIANwECIABB3OgBOwEADAgLIABBgAQ7AQogAEIANwECIABB3OQBOwEADAcLIABBgAQ7AQogAEIANwECIABB3NwBOwEADAYLIABBgAQ7AQogAEIANwECIABB3LgBOwEADAULIABBgAQ7AQogAEIANwECIABB3OAAOwEADAQLIAJBgAJxRQ0BIABBgAQ7AQogAEIANwECIABB3M4AOwEADAMLIAJBgIAEcQ0BCwJ/QQAgAUEgSQ0AGkEBIAFB/wBJDQAaIAFBgIAETwRAIAFB4P//AHFB4M0KRyABQf7//wBxQZ7wCkdxIAFBwO4Ka0F6SXEgAUGwnQtrQXJJcSABQfDXC2tBcUlxIAFBgPALa0HebElxIAFBgIAMa0GedElxIAFB0KYMa0F7SXEgAUGAgjhrQbDFVElxIAFB8IM4SXEgAUGAgAhPDQEaIAFBpLbAAEEsQfy2wABB0AFBzLjAAEHmAxA5DAELIAFBsrzAAEEoQYK9wABBogJBpL/AAEGpAhA5C0UEQCAEQQA6ABYgBEEAOwEUIAQgAUEUdkGrrcAAai0AADoAFyAEIAFBBHZBD3FBq63AAGotAAA6ABsgBCABQQh2QQ9xQautwABqLQAAOgAaIAQgAUEMdkEPcUGrrcAAai0AADoAGSAEIAFBEHZBD3FBq63AAGotAAA6ABggAUEBcmdBAnYiAiAEQRRqIgNqIgVB+wA6AAAgBUEBa0H1ADoAACADIAJBAmsiAmpB3AA6AAAgBEEcaiIDIAFBD3FBq63AAGotAAA6AAAgAEEKOgALIAAgAjoACiAAIAQpAhQ3AgAgBEH9ADoAHSAAQQhqIAMvAQA7AQAMAgsgACABNgIEIABBgAE6AAAMAQsgAEGABDsBCiAAQgA3AQIgAEHcxAA7AQALIARBIGokAAv7DAILfwF+IwBBgAFrIgQkACAEIAM2AggCQAJAAkACQCACQQFrIg0OAgIBAAsgBCANNgIgIAQgATYCGCAEIAEgAmo2AhwgBCAEQQhqNgIkIARB4ABqIQsjAEFAaiIFJAAgBEEYaiIJKAIIIgMEQCAJKAIEIAkoAgBrIgIgAyACIANJGyEHCyAHrUIMfiIPpyEGAkACQCAPQiCIpyAGQfz///8HS3INAEEAIQICQCAGRQRAQQQhCkEAIQcMAQtBqcrAAC0AABpBBCEIIAZBBBCiASIKRQ0BCyAFQQA2AgwgBSAKNgIIIAUgBzYCBAJAIANFDQACQCAHIAkoAgQiCCAJKAIAIglrIgIgAyACIANJGyIGSQRAIAVBBGpBACAGQQRBDBBIIAUoAgwhAiAFKAIIIQoMAQtBACECIAggCUYNAQsgAiAGaiAKIAJBDGxqIQcgBUEcaq1CgICAgCCEIQ8DQCAFIAk2AhwgBUGgocAANgIgIAVCATcCLCAFIA83AzggBSAFQThqNgIoIAVBATYCJCAFQRBqIAVBIGoQNiAHQQhqIAVBGGooAgA2AgAgByAFKQIQNwIAIAdBDGohByAJQQFqIQkgBkEBayIGDQALIQILIAsgBSkCBDcCACALQQhqIAI2AgAgBUFAayQADAELIAggBkHYicAAEJIBAAsgBEEMaiELIAQoAmQhByAEKAJoIQMjAEEwayIGJAACQAJAAkAgA0UEQCALQQA2AgggC0KAgICAEDcCAAwBCwJAIANBDGwiCUEMa0EMbq1CAYYiD0IgiFAEQCAPpyEKIAkhBSAHIQIDQCAFRQ0CIAVBDGshBSAKIAJBCGooAgAgCmoiCk0gAkEMaiECDQALC0GUjcAAQTVBlI7AABBuAAtBACEFAkACQCAKQQBIDQACQCAKRQRAQQEhAgwBC0GpysAALQAAGkEBIQUgCkEBEKIBIgJFDQELQQAhCCAGQQA2AhQgBiACNgIQIAdBCGooAgAhBSAGIAo2AgwgB0EEaigCACEMIAUgCksEQCAGQQxqQQAgBUEBQQEQSCAGKAIUIQggBigCECECCyACIAhqIAwgBRAlGiAKIAUgCGoiCGshBSACIAhqIQIgA0EBRg0BIAlBDGshDCAHQRRqIQkDQCAFQQFNDQQgCUEEaygCACEOIAkoAgAhCCACQeiJwAAvAAA7AAAgBUECayIFIAhJDQQgCUEMaiEJIAUgCGshBSACQQJqIA4gCBAlIAhqIQIgDEEMayIMDQALDAELIAUgCkGkjsAAEJIBAAsgCyAGKQIMNwIAIAtBCGogCiAFazYCAAsgBkEwaiQADAELIAZBADYCKCAGQQE2AhwgBkHAjsAANgIYIAZCBDcCICAGQRhqQciOwAAQhQEACyADBEAgByECA0AgAigCACIFBEAgAkEEaigCACAFEKkBCyACQQxqIQIgA0EBayIDDQALCyAEKAJgIgIEQCAHIAJBDGwQqQELIAQgASANajYCXCAEQQE2AmQgBEHkiMAANgJgIARCATcCbCAEIARB3ABqrUKAgICAIIQ3A3ggBCAEQfgAajYCaCAEQdAAaiIBIARB4ABqEDYgBCABrUKAgICAEIQ3A0ggBCAEQQxqrUKAgICAEIQ3A0AgBEECNgIsIARB8InAADYCKCAEQgI3AjQgBCAEQUBrNgIwIAAgBEEoahA2IAQoAlAiAARAIAQoAlQgABCpAQsgBCgCDCIARQ0CIAQoAhAgABCpAQwCCyAEIAE2AkAgBEEBNgJkIARB5IjAADYCYCAEQgE3AmwgBCAEQUBrIgKtQoCAgIAghDcDKCAEIARBKGoiAzYCaCAEQQxqIgUgBEHgAGoiBxA2IAQgAUEBajYCXCAEQQE2AmQgBEHkiMAANgJgIARCATcCbCAEIARB3ABqrUKAgICAIIQ3A3ggBCAEQfgAajYCaCAEQdAAaiIBIAcQNiAEIAGtQoCAgIAQhDcDSCAEIAWtQoCAgIAQhDcDQCAEQQI2AiwgBEHwiMAANgIoIARCAjcCNCAEIAI2AjAgACADEDYgBCgCUCIABEAgBCgCVCAAEKkBCyAEKAIMIgBFDQEgBCgCECAAEKkBDAELIAQgATYCQCAEQQE2AmQgBEHkiMAANgJgIARCATcCbCAEIARBQGutQoCAgIAghDcDKCAEIARBKGo2AmggACAEQeAAahA2CyAEQYABaiQAC68FAQp/IwBBEGsiAiQAIAJBADYCDCACQoCAgIAQNwIEIAEoAhQhAwJAIAEoAgwiCEEBRwRAIAMhBwwBCyABKAIcIgZBAWsgAyADIAZLIgUbIQcgA0EBaiAGIAUbIQkLAkAgB0EBRg0AIAEoAigiA0UNACADIAEoAiQiA2ohCiAHQQJrIQtBACEBA0ACfyADLAAAIgRBAE4EQCAEQf8BcSEEIANBAWoMAQsgAy0AAUE/cSEFIARBH3EhBiAEQV9NBEAgBkEGdCAFciEEIANBAmoMAQsgAy0AAkE/cSAFQQZ0ciEFIARBcEkEQCAFIAZBDHRyIQQgA0EDagwBCyAGQRJ0QYCA8ABxIAMtAANBP3EgBUEGdHJyIQQgA0EEagshAyACKAIEIAFGBEAgAkEEakGEjcAAEFILIAIoAgggAWpBCUEgIARBCUYbOgAAIAIgAUEBaiIENgIMIAEgC0YNASAEIQEgAyAKRw0ACwsCfyAIRQRAIAIoAgQgBGtBA00EfyACQQRqIARBBEEBQQEQSCACKAIMBSAECyACKAIIakHe2rTpAjYAACACKAIMQQRqDAELIAIoAgQhASAJIAdrIgNBAU0EQCABIARGBEAgAkEEakGEjcAAEFILIAIoAgggBGpB3gA6AAAgBEEBagwBCyABIARGBEAgAkEEakGEjcAAEFILIAIoAgggBGpB3gA6AAAgAiAEQQFqIgE2AgwgA0ECRwRAIANBAmshAwNAIAIoAgQgAUYEQCACQQRqQYSNwAAQUgsgAigCCCABakEtOgAAIAIgAUEBaiIBNgIMIANBAWsiAw0ACwsgAigCBCABRgRAIAJBBGpBhI3AABBSCyACKAIIIAFqQd4AOgAAIAFBAWoLIQEgACACKQIENwIAIABBCGogATYCACACQRBqJAAL3QUBDH8gASABLQBYIgZBAUc6AFggAUE8aiEJIAEoAiwhAyABKAJQIQUgASgCTCEHIAEoAkghCCABKAIIIQsgASgCRCICIAEoAjxGBEAgCUHwkcAAEFALIAFBJGohCiABKAJAIAJBAnRqIAM2AgAgASACQQFqNgJEAkACQAJAAkAgASgCUCICQX1LDQAgASgCTCACQQJqSQ0AIAEoAkggAmovAABB3boBRw0AIAghAiAHIQMgBSEEDAELIAEgBjoAWCABIAU2AlAgASAHNgJMIAEgCDYCSCAKEEMgASABLQBYIgZBAUc6AFggASgCLCENIAEoAlAhBCABKAJMIQMgASgCSCECIAEoAkQiDCABKAI8RgRAIAlB8JHAABBQCyABKAJAIAxBAnRqIA02AgAgASAMQQFqNgJEAkAgASgCUCIJQX1LDQAgASgCTCAJQQJqSQ0AIAEoAkggCWovAABB27YBRg0BCyABIAY6AFggASAENgJQIAEgAzYCTCABIAI2AkggChBDIAEoAkwhAyABKAJIIQQCQAJAIAEoAlAiAkUNACACIANPBEAgAiADRg0BDAILIAIgBGosAABBv39MDQELIAIgA0YNAkEBIQcCQCACIARqIgUsAAAiCEEATg0AIAUtAAFBP3EhBCAIQR9xIQMCfyADQQZ0IARyIAhBYEkN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AXMLIANB0ABqJABBAXEL6gQBCn8jAEEwayIDJAAgAyABNgIsIAMgADYCKCADQQM6ACQgA0IgNwIcIANBADYCFCADQQA2AgwCfwJAAkACQCACKAIQIgpFBEAgAigCDCIARQ0BIAIoAggiASAAQQN0aiEEIABBAWtB/////wFxQQFqIQcgAigCACEAA0AgAEEEaigCACIFBEAgAygCKCAAKAIAIAUgAygCLCgCDBECAA0ECyABKAIAIANBDGogAUEEaigCABEBAA0DIABBCGohACABQQhqIgEgBEcNAAsMAQsgAigCFCIARQ0AIABBBXQhCyAAQQFrQf///z9xQQFqIQcgAigCCCEFIAIoAgAhAANAIABBBGooAgAiAQRAIAMoAiggACgCACABIAMoAiwoAgwRAgANAwsgAyAIIApqIgFBEGooAgA2AhwgAyABQRxqLQAAOgAkIAMgAUEYaigCADYCICABQQxqKAIAIQRBACEJQQAhBgJAAkACQCABQQhqKAIAQQFrDgIAAgELIARBA3QgBWoiDCgCAA0BIAwoAgQhBAtBASEGCyADIAQ2AhAgAyAGNgIMIAFBBGooAgAhBAJAAkACQCABKAIAQQFrDgIAAgELIARBA3QgBWoiBigCAA0BIAYoAgQhBAtBASEJCyADIAQ2AhggAyAJNgIUIAUgAUEUaigCAEEDdGoiASgCACADQQxqIAFBBGooAgARAQANAiAAQQhqIQAgCyAIQSBqIghHDQALCyAHIAIoAgRPDQEgAygCKCACKAIAIAdBA3RqIgAoAgAgACgCBCADKAIsKAIMEQIARQ0BC0EBDAELQQALIANBMGokAAuKBAEEfyMAQYABayIEJAACQAJAAkAgASgCFCICQRBxRQRAIAJBIHENAUEBIQIgACgCACABED9FDQIMAwsgACgCACECA0AgAyAEakH/AGogAkEPcSIFQTByIAVB1wBqIAVBCkkbOgAAIANBAWshAyACQRBJIAJBBHYhAkUNAAtBASECIAFBl7DAAEECIAMgBGpBgAFqQQAgA2sQHkUNAQwCCyAAKAIAIQIDQCADIARqQf8AaiACQQ9xIgVBMHIgBUE3aiAFQQpJGzoAACADQQFrIQMgAkEPSyACQQR2IQINAAtBASECIAFBl7DAAEECIAMgBGpBgAFqQQAgA2sQHg0BCyABKAIcQamt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BQJAIAJBBEkEQEEAIQIMAQsgB0EcaiEDIAJBfHEhCEEAIQIDQCADKAIAIANBCGsoAgAgA0EQaygCACADQRhrKAIAIAJqampqIQIgA0EgaiEDIAggBkEEaiIGRw0ACwsgBQRAIAZBA3QgB2pBBGohAwNAIAMoAgAgAmohAiADQQhqIQMgBUEBayIFDQALCyABKAIMBEAgAkEASA0BIAcoAgRFIAJBEElxDQEgAkEBdCECC0EAIQUgAkEASA0DIAINAQtBASEDQQAhAgwBC0GpysAALQAAGkEBIQUgAkEBEKIBIgNFDQELIARBADYCCCAEIAM2AgQgBCACNgIAIARB0KrAACABECpFDQFB7KvAAEHWACAEQQ9qQdyrwABB3KzAABBjAAsgBSACQcyrwAAQkgEACyAAIAQpAgA3AgAgAEEIaiAEQQhqKAIANgIAIARBEGokAAuIAwEEfyMAQdAAayICJAAgAkHIAGogARARIAIoAkwhAQJAIAIoAkhFDQACQCABKAJQIgMgASgCTE8NACABKAJIIANqLQAAQSBHDQAgASADQQFqNgJQDAELIAJBQGsgARAIIAIoAkQhASACKAJARQ0AIAEoAiwhBSABKAJEIgMgASgCPEYEQCABQTxqQfCRwAAQUAsgASgCQCADQQJ0aiAFNgIAIAEgA0EBajYCRCACQThqIAEQGiACKAI8IQEgAigCOEUEQCABKAJEIgNFDQEgASADQQFrNgJEDAELIAFBJGoQQyACQTBqIAEQGyACKAI0IQEgAigCMEUNACACQShqIAEQFSACKAIsIQEgAigCKEUNACACQSBqIAEQGSACKAIkIQEgAigCIEUNACACQRhqIAEQBiACKAIcIQEgAigCGEUNACACQRBqIAEQDCACKAIUIQEgAigCEEUNACACQQhqIAEQDSACKAIMIQEgAigCCCEECyAAIAE2AgQgACAENgIAIAJB0ABqJAALiAMCBH8BfiMAQUBqIgYkAEEBIQcCQCAALQAEDQAgAC0ABSEIIAAoAgAiBS0AFEEEcUUEQCAFKAIcQYewwABBhLDAACAIQQFxIggbQQJBAyAIGyAFKAIgKAIMEQIADQEgBSgCHCABIAIgBSgCICgCDBECAA0BIAUoAhxB1K/AAEECIAUoAiAoAgwRAgANASADIAUgBCgCDBEBACEHDAELIAhBAXFF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BUEIajYCNCADIAVBGGogBCgCDBEBAA0BIAUoAjRBjLDAAEECIAUoAjgoAgwRAgANAQsCQCACDQAgAC0AFEEEcQ0AIAAoAhxBlLDAAEEBIAAoAiAoAgwRAgANAQsgACgCHEGorcAAQQEgACgCICgCDBECACEGCyAFQUBrJAAgBgu5AgEKfyAAKAIgIgFFBEAgAEEANgIIIABBADYCFA8LIAAgAUEBayICNgIgIAAoAggiASAAKAIcIAJBAnRqKAIAIgJPBEACQCABIAJHBEAgAkEUbCABQRRsIgFrIQQgAEEMaiEGIAEgACgCBGpBFGshAQNAAkAgASgCAEUEQCAAKAIUIgNFDQEgACADQQFrNgIUDAELIAFBEGooAgAhByABQQxqKAIAIQggAUEIaigCACEJIAFBBGooAgAhCiAAKAIUIgUgACgCDEYEQCAGQYCSwAAQTwsgACgCECAFQQR0aiIDIAc2AgwgAyAINgIIIAMgCTYCBCADIAo2AgAgACAFQQFqNgIUCyABQRRrIQEgBEEUaiIEDQALIAAoAgggAkkNAQsgACACNgIICw8LIAIgAUGQksAAEKoBAAvAAgIEfwF+IwBBQGoiAiQAQQEhBAJAIAAtAAQNACAALQAFIQUCQCAAKAIAIgMtABRBBHFFBEAgBUEBcUUNASADKAIcQYewwABBAiADKAIgKAIMEQIARQ0BDAILIAVBAXFFBEAgAygCHEGVsMAAQQEgAygCICgCDBECAA0CCyACQQE6ABcgAkEgaiADQQhqKQIANwMAIAJBKGogA0EQaikCADcDACACQTBqIANBGGooAgA2AgAgAiADKQIcNwIIIAMpAgAhBiACQeivwAA2AjggAiAGNwMYIAIgAkEXajYCECACIAJBCGo2AjQgASACQRhqQbiQwAAoAgARAQANASACKAI0QYywwABBAiACKAI4KAIMEQIAIQQMAQsgASADQbiQwAAoAgARAQAhBAsgAEEBOgAFIAAgBDoABCACQUBrJAALwQICA38BfiMAQUBqIgIkACAAKAIAIQQgAAJ/QQEgAC0ACA0AGiAAKAIEIgMtABRBBHFFBEBBASADKAIcQYewwABBkbDAACAEG0ECQQEgBBsgAygCICgCDBECAA0BGiABIANB7JTAACgCABEBAAwBCyAERQRAQQEgAygCHEGSsMAAQQIgAygC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RQ0AGkGpysAALQAAGiACIAEQogELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALlgMBBX8jAEFAaiICJAAgAkHYlcAANgI4IAJByJXAADYCMCACQbiVwAA2AiggAkGolcAANgIgIAJBmJXAADYCGCACQYiVwAA2AhAgAiAANgIUIAIgAEEgajYCLCACIABBxABqNgIkIAIgAEEMajYCHCACIABBLGo2AgwgAiAAQdAAajYCPCACIAJBPGo2AjQgAkEMaiEEQQYhBkGYlsAAIQMjAEEgayIAJAAgAEEGNgIAIABBBjYCBCABKAIcQciWwABBBSABKAIgKAIMEQIAIQUgAEEAOgANIAAgBToADCAAIAE2AggDQCAAQQhqIAMoAgAgA0EEaigCACAEQYyywAAQOCEFIARBCGohBCADQQhqIQMgBkEBayIGDQALIAAtAA0iAyAALQAMIgRyIQECQCADQQFxRSAEQQFxcg0AIAUoAgAiAS0AFEEEcUUEQCABKAIcQY+wwABBAiABKAIgKAIMEQIAIQEMAQsgASgCHEGOsMAAQQEgASgCICgCDBECACEBCyAAQSBqJAAgAUEBcSACQUBrJAALlQEBA38jAEGAIGsiBSQAAkACQCABQQF2IgNBgKToAyABIAFBgKToA08bIgQgAyAESxsiA0GBIE8EQEGpysAALQAAGiADQQEQogEiBEUNAiAAIAEgBCADIAFBwQBJIAIQCSAEIAMQqQEMAQsgACABIAVBgCAgAUHBAEkgAhAJCyAFQYAgaiQADwtBASADQYSiwAAQkgEAC30BAn8gA0EITwRAIAAgACADQQN2IgNBAnQiBGogACADQQdsIgVqIAMQXyEAIAEgASAEaiABIAVqIAMQXyEBIAIgAiAEaiACIAVqIAMQXyECCyAAIAIgASAALQAAIgAgAS0AACIBSSIDIAEgAi0AACICSXMbIAMgACACSXMbC5gBAQN/IAAtAAghAQJAIAAoAgAiA0UEQCABIQIMAQtBASECAkAgAUEBcUUEQCADQQFHDQEgAC0ACUUNASAAKAIEIgEtABRBBHENASABKAIcQZSwwABBASABKAIgKAIMEQIARQ0BCyAAIAI6AAgMAQsgACAAKAIEIgAoAhxBqK3AAEEBIAAo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AkEPSyACQQR2IQINAAsgAUGXsMAAQQIgACAEakGAAWpBACAAaxAeIARBgAFqJAALMQEBf0EEIQECQCAAEIsBRQ0AIAAEQEGpysAALQAAGiAAQQQQogEiAUUNAQsgAQ8LAAs4AAJAIAJBgIDEAEYNACAAIAIgASgCEBEBAEUNAEEBDwsgA0UEQEEADwsgACADIAQgASgCDBECAAsvAQF/IwBBEGsiAiQAIAJBCGogABB8IAIoAgggASACKAIMKAIQEQEAIAJBEGokAAs6AQF/IwBBIGsiACQAIABBADYCGCAAQQE2AgwgAEGIs8AANgIIIABCBDcCECAAQQhqQcCzwAAQhQEACzgBAX9BASEBIAAtAARFBEAgACgCACIBKAIcQZawwABBASABKAIgKAIMEQIAIQELIAAgAToABCABCzAAIAAgASgCHEEBQQAgASgCICgCDBECADoACCAAIAE2AgQgAEEBOgAJIABBADYCAAtQAQF/IwBBEGsiAyQAIAMgAjYCDCADIAE2AgggAyAANgIEIwBBEGsiACQAIAAgA0EEaiIBKQIANwIIIABBCGpBrKrAACABKAIIQQFBABBWAAv6AQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQZCqwAAgASgCBCABKAIIIgAtAAggAC0ACRBWAAsgACADNgIEIAAgAjYCACAAQfSpwAAgASgCBCABKAIIIgAtAAggAC0ACRBWAAsxAQF/IAAgASgCOEENIAEoAixBgICAgHhGIgIbNgIEIAAgASgCNEH4lsAAIAIbNgIACzIBAX8gASgCHEHErcAAQQEgASgCICgCDBECACECIABBADoABSAAIAI6AAQgACABNgIACx8AAkAgARCLAQRAIAAgAUEEIAIQlgEiAA0BCwALIAALJAEBfyAAKAIAIgFBgICAgHhGIAFFckUEQCAAKAIEIAEQqQELCygAIAEgACgCAC0AAEECdCIAQcSewABqKAIAIABB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ZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnOABBAAWAAAALMHAAAJAAAALCAsIG9yIAABAAAAAAAAAOoEEAAFAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcGVzdC0yLjEuMy9zcmMvcG9zaXRpb24ucnMASwUQAFwAAADKAAAAFAAAAHBvc2l0aW9uIG91dCBvZiBib3VuZHMAAEsFEABcAAAAxwAAAA0AAABLBRAAXAAAAI4AAAAgAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZUsFEABcAAAArQAAABkAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAKAYQAEoAAAChAAAAGQAAAAAFEABLAAAAjQUAABsAAABhdHRlbXB0IHRvIGpvaW4gaW50byBjb2xsZWN0aW9uIHdpdGggbGVuID4gdXNpemU6Ok1BWC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5ycwAAAMkGEABIAAAAmgAAAAoAAADJBhAASAAAAJ0AAAAWAAAAbWlkID4gbGVuAAAANAcQAAkAAADJBhAASAAAALEAAAAWAAAABQAAAAQAAAAEAAAABgAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWVzcmMvbGliLnJzAAAAkwcQAAoAAAALAAAAGgAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuODAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzALAHEABrAAAAmgAAABIAAAAAAAAABAAAAAQAAAACAAAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheS9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3Blc3QtMi4xLjMvc3JjL3N0YWNrLnJzAAAAZAgQAFkAAAA0AAAAFgAAAGQIEABZAAAALAAAABIAAABkCBAAWQAAAC0AAAAUAAAAZAgQAFkAAABAAAAAGAAAAGQIEABZAAAAYAAAACAAAABkCBAAWQAAAFkAAAAmAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcGVzdC0yLjEuMy9zcmMvaXRlcmF0b3JzL3BhaXIucnMAACAJEABiAAAA+gAAABkAAAAgCRAAYgAAAPEAAAAZAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZSAJEABiAAAA9QAAABIAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpcnMucnMA3AkQAGMAAADDAAAAGQAAANwJEABjAAAAxwAAABIAAAAAAAAABAAAAAQAAAAHAAAAUG9zAAAAAAAEAAAABAAAAAgAAABTcGFuCQAAABgAAAAEAAAACgAAAAAAAAAMAAAABAAAAAsAAAAAAAAAFAAAAAQAAAAMAAAADQAAAAwAAAAEAAAADgAAAA8AAAAMAAAABAAAABAAAAAAAAAABAAAAAQAAAARAAAAdmFyaWFudGxvY2F0aW9ubGluZV9jb2xwYXRobGluZWNvbnRpbnVlZF9saW5lAAAA6AoQAAcAAADvChAACAAAAPcKEAAIAAAA/woQAAQAAAADCxAABAAAAAcLEAAOAAAARXJyb3IAAAAAAAAACAAAAAQAAAASAAAATm9uZQAAAAAEAAAABAAAABMAAABTb21lcGFyc2luZyBlcnJvcgAAABQAAABcAAAABAAAABUAAAAUAAAAXAAAAAQAAAAWAAAAFQAAAIgLEAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAABgAAAABAAAAB0AAAAcAAAAYAAAAAQAAAAeAAAAHQAAAMQLEAAfAAAAIAAAACEAAAAiAAAAGwAAACMAAAAkAAAAJQAAACYAAAAnAAAADwAAAAwAAAAEAAAAKAAAAAAAAAAEAAAABAAAACkAAABQYXJzaW5nRXJyb3Jwb3NpdGl2ZXNuZWdhdGl2ZXNDdXN0b21FcnJvcm1lc3NhZ2UvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpci5ycwAAZAwQAGIAAAB0AAAAFAAAAGQMEABiAAAAUwAAABkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlZAwQAGIAAABVAAAAEgAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAgDRAASwAAAI0FAAAbAAAAc3JjL3BhcnNlci5ycwAAAHwNEAANAAAAJgAAAC8AAAB8DRAADQAAADAAAAAaAAAAfA0QAA0AAAAxAAAAGgAAAHwNEAANAAAALQAAAB8AAAB8DRAADQAAAC4AAAAfAAAAIA0QAEsAAADqAQAAFwAAAHwNEAANAAAAPAAAAC4AAAB8DRAADQAAAEEAAAAfAAAARU9JU3BhY2VDbkVuZ051bU11bHRpU3BhY2VGV1B1bmN0UHVuY3RlbXBoYXNpc01hcmtpbmxpbmVFbUNoYXJJbmxpbmVFbWlubGluZUNvZGVDaGFySW5saW5lQ29kZWlubGluZU1hdGhDaGFySW5saW5lTWF0aGRvY0NoYXJEb2NMaW5rdXJsU2NoZW1hdXJsQm9keVVSTGhvdXJtaW5TZWNUaW1lU3BlY2lhbEJsb2NrT3RoZXJDaGFyT3RoZXJCbG9ja0xpbmUDAAAABQAAAAIAAAADAAAAAwAAAAoAAAAHAAAABQAAAAwAAAAMAAAACAAAAA4AAAAKAAAADgAAAAoAAAAHAAAABwAAAAkAAAAHAAAAAwAAAAQAAAAGAAAABAAAAAwAAAAJAAAABQAAAAUAAAAEAAAADA4QAA8OEAAUDhAAFg4QABkOEAAcDhAAJg4QAC0OEAAyDhAAPg4QAEoOEABSDhAAYA4QAGoOEAB4DhAAgg4QAIkOEACQDhAAmQ4QAKAOEACjDhAApw4QAK0OEACxDhAAvQ4QAMYOEADLDhAA0A4QAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnO0DxAATAAAACgCAAARAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3N0YWJsZS9xdWlja3NvcnQucnNtaWQgPiBsZW5vEBAACQAAABAQEABfAAAATAAAAB8AAAAQEBAAXwAAAEYAAAAXAAAAAQAAAAAAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAqBAQAEoAAAChAAAAGQAAAKgQEABKAAAAlQMAAAkAAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnN+ERAASgAAAKEAAAAZAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzANgREABLAAAA6gEAABcAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzNBIQAEwAAAAoAgAAEQAAAOKQjeKQigAAAAAAABAAAAAEAAAAKwAAACwAAAAtAAAAAQAAAAAAAAAKCkNhdXNlZCBieToKAAAAAAAAABAAAAAEAAAAKwAAACwAAAAtAAAAICAgIDogAAABAAAAAAAAAOQSEAACAAAAICAgICAgIC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAA/xIQAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNcExAATAAAACgCAAARAAAALwAAAAwAAAAEAAAAMAAAADEAAAAyAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNy9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkANATEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADQExAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAeBQQABUAAACNFBAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc6wUEAAYAAAAYwEAAAkAAAAvAAAADAAAAAQAAAAzAAAAAAAAAAgAAAAEAAAANAAAAAAAAAAIAAAABAAAADUAAAA2AAAANwAAADgAAAA5AAAAEAAAAAQAAAA6AAAAOwAAADwAAAA9AAAAAAAAAAgAAAAEAAAAPgAAAD8AAABAAAAAPQAAAEVycm9yAAAAQQAAAAwAAAAEAAAAQgAAAEMAAABEAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAABoFRAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOEFRAAHAAAACgCAAARAAAAbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzALAVEAAbAAAA6gEAABcAQeSrwAALwh4BAAAARQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90bGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAABCFhAAGAAAAIoCAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAGwWEAAaAAAAoQAAABkAAACwFRAAGwAAAI0FAAAbAAAAKS4uMDEyMzQ1Njc4OWFiY2RlZgABAAAAAAAAAFtjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAAPAWEAAgAAAAEBcQABIAAAAAAAAABAAAAAQAAABLAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAATxcQABAAAABfFxAAFwAAAHYXEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAAE8XEAAQAAAAmBcQABAAAACoFxAACQAAAHYXEAAJAAAAOiAAAAEAAAAAAAAA1BcQAAIAAAAAAAAADAAAAAQAAABMAAAATQAAAE4AAAAgICAgIHsgLCAgewosCn0gfSgoCiwKXTB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlsaWJyYXJ5L2NvcmUvc3JjL2ZtdC9tb2QucnPhGBAAGwAAACcJAAAJAAAAAAAAAAgAAAAEAAAARgAAAOEYEAAbAAAAoAoAACYAAADhGBAAGwAAAKkKAAAaAAAAdXNlci1wcm92aWRlZCBjb21wYXJpc29uIGZ1bmN0aW9uIGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgYSB0b3RhbCBvcmRlcjwZEABMAAAAbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3NoYXJlZC9zbWFsbHNvcnQucnMAkBkQAC8AAABhAwAABQAAAGxpYnJh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");

// liberty-web/charliberty.js
var wasm;
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
function formatLine(line) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.formatLine(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
var cachegetUint32Memory0 = null;
function getUint32Memory0() {
  if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachegetUint32Memory0;
}
function getArrayU32FromWasm0(ptr, len) {
  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
function getBlockRanges(line, cursor_pos) {
  const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getBlockRanges(ptr0, len0, cursor_pos);
  return Blocks.__wrap(ret);
}
var Blocks = class {
  static __wrap(ptr) {
    const obj = Object.create(Blocks.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_blocks_free(ptr);
  }
  get special() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_special(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  get emphasis() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_emphasis(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
function load(module2, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module2, imports);
        } catch (e) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module2.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  });
}
function init(input) {
  return __async(this, null, function* () {
    if (typeof input === "undefined") {
      input = new URL("charliberty_bg.wasm", "");
    }
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    const { instance, module: module2 } = yield load(yield input, imports);
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module2;
    return wasm;
  });
}
var charliberty_default = init;

// src/const.ts
var FW;
((FW2) => {
  FW2.DOT = "\xB7";
  FW2.MONEY = "\uFFE5";
  FW2.FULLSTOP = "\u3002";
  FW2.LT = "\u300A";
  FW2.GT = "\u300B";
  FW2.SLASH = "\u3001";
  FW2.LEFTQUO = "\u201C";
  FW2.RIGHTQUO = "\u201D";
  FW2.LEFTPAREN = "\uFF08";
  FW2.RIGHTPAREN = "\uFF09";
})(FW || (FW = {}));
var SW;
((SW2) => {
  SW2.DOT = "`";
  SW2.MONEY = "$";
  SW2.FULLSTOP = ".";
  SW2.LT = "<";
  SW2.GT = ">";
  SW2.SLASH = "/";
  SW2.LEFTQUO = '"';
  SW2.RIGHTQUO = '"';
  SW2.LEFTPAREN = "(";
  SW2.RIGHTPAREN = ")";
})(SW || (SW = {}));
var PUNCTS = new Set(" \uFF0C\u3002\uFF1A\uFF1F,.:?");
var DEFAULT_RULES = String.raw`
# Line head conversion
# Note: this rule can't apply to the very first line of the document
'\n|' -> '\n>|'
'\n|' -> '\n/|'

# CN symbols to EN
'|' -> '.|'
'|' -> '>|'
'|' -> '/|'
'|' -> ';|'
'|' -> ',|'

# Auto-pair, Input Conversion, and Deletion
'|' -> '<|' # this one take higer priority than the next line
'|'    -> '|'
'|'   -x '|'
'|' -> '(|)'
'|'     -> '|'
'|'   -x '|'

# Auto code block
'|'  -> '\`|\`' # inline block
'\`|\`' -> '\`\`\`|\n\`\`\`'

# have fun converting!
'dpx|' -> 'don\'t panic|'


# Selection Insert Rules
''  -> '\`' + '\`'
''  -> '$' + '$'
''  -> '' + ''
'<'  -> '<' + '>'
`.replaceAll("\\`", "`");

// src/utils.ts
var config;
function initLog(cfg) {
  config = cfg;
}
function log(format, ...parts) {
  if (config != void 0 && config.debug) {
    parts.forEach((v, idx) => {
      if (typeof v === "string" || v instanceof String) {
        parts[idx] = JSON.stringify(v);
      }
    });
    console.log(format, ...parts);
  }
}

// src/ext_convert.ts
var import_fs = require("fs");
var import_path = require("path");
var EOF = "EOF";
var ANCHOR = "\xA6";
var DEL_TRIG = "\u274C";
var ParseResult = class {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }
  get isOk() {
    return this.error == "";
  }
};
function Ok(val) {
  return new ParseResult(val, "");
}
function Err(err) {
  return new ParseResult(null, err);
}
function findOnlyAnchor(s) {
  let res = -1, idx = 0;
  for (const ch of s) {
    if (ch === ANCHOR) {
      if (res == -1) {
        res = idx;
      } else {
        return -2;
      }
    }
    idx++;
  }
  return res;
}
function prefixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = 0; i < s1.length; i++) {
    if (s1[i] != s2[i])
      return false;
  }
  return true;
}
function suffixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = s1.length - 1, j = s2.length - 1; i > -1; i--, j--) {
    if (s1[i] != s2[j])
      return false;
  }
  return true;
}
var Rule = class {
};
var SideRule = class {
  constructor(trig, left, right) {
    this.trig = trig;
    this.left = left;
    this.right = right;
  }
  get isValid() {
    return this.trig.length === 1;
  }
};
var ConvRule = class {
  constructor(left, right, isForDelete = false) {
    this.isForDelete = isForDelete;
    this.left = Array.from(left);
    this.right = Array.from(right);
    this.lanchor = findOnlyAnchor(this.left);
    this.ranchor = findOnlyAnchor(this.right);
    if (this.lanchor > 0 && isForDelete) {
      this.left.splice(this.lanchor, 0, DEL_TRIG);
      this.lanchor += 1;
    }
    this.innerTrig = this.left[this.lanchor - 1];
    this.rBeforeAnchorLen = this.right.slice(0, this.ranchor).reduce((acc, cur) => acc + cur.length, 0);
    this.lBeforeAnchorLen = this.left.slice(0, this.lanchor).reduce((acc, cur) => acc + cur.length, 0);
    this.lBefore2AnchorLen = this.left.slice(0, this.lanchor - 1).reduce((acc, cur) => acc + cur.length, 0);
    if (isForDelete) {
      this.lBefore3AnchorLen = this.left.slice(0, this.lanchor - 2).reduce((acc, cur) => acc + cur.length, 0);
    }
    this.lAfterAnchorLen = this.left.slice(this.lanchor + 1).reduce((acc, cur) => acc + cur.length, 0);
    this.replace = this.right.slice(0, this.ranchor).join("") + this.right.slice(this.ranchor + 1).join("");
  }
  get isValid() {
    return this.lanchor > 0 && this.ranchor >= 0;
  }
  invalidReasons() {
    const reasons = [];
    if (this.lanchor < 0) {
      reasons.push(`Expected one | on left side, but found ${this.lanchor == -1 ? "none" : "multiple"}`);
    } else if (this.lanchor === 0) {
      reasons.push("Invalid Placement of | on the left side. Note: left side cannot start with |");
    }
    if (this.ranchor < 0) {
      reasons.push(`Expected one | on right side, but found ${this.ranchor == -1 ? "none" : "multiple"}`);
    }
    return reasons.join("\n");
  }
  get trigHintChar() {
    if (this.isForDelete) {
      return this.left[this.lanchor - 2];
    } else {
      return this.left[this.lanchor - 1];
    }
  }
  canConvert(inputS, insChr, insPosBaseHead) {
    if (!this.isValid || insChr != this.innerTrig)
      return false;
    const { left, lanchor } = this;
    if (!suffixOf(left.slice(0, lanchor - 1), Array.from(inputS.slice(0, insPosBaseHead))))
      return false;
    return prefixOf(left.slice(lanchor + 1), Array.from(inputS.slice(insPosBaseHead)));
  }
  leftMatchPart() {
    return this.left.slice(0, this.lanchor);
  }
  mapToChanges(pos, isDel) {
    const { lBefore3AnchorLen, lBefore2AnchorLen, lBeforeAnchorLen, lAfterAnchorLen, rBeforeAnchorLen } = this;
    let modificationSpan;
    let startOffset;
    if (isDel) {
      pos = pos - 1;
      startOffset = lBefore3AnchorLen;
      modificationSpan = lBefore3AnchorLen + lAfterAnchorLen;
    } else {
      startOffset = lBefore2AnchorLen;
      modificationSpan = lBeforeAnchorLen + lAfterAnchorLen;
    }
    const from = pos - startOffset;
    if (from < 0) {
      console.log("bad pos for map", pos, lBefore2AnchorLen, this.left, this.right);
    }
    const to = from + modificationSpan;
    const newPos = from + rBeforeAnchorLen;
    return {
      changes: { from, to, insert: this.replace },
      selection: { anchor: newPos, head: newPos }
    };
  }
};
var readable = JSON.stringify;
var RuleParser = class {
  constructor(input, justCheck = false, basePath = "") {
    this.idx = 0;
    this.input = Array.from(input);
    this.convRules = [];
    this.sideRules = /* @__PURE__ */ new Map();
    this.errors = [];
    this.justCheck = justCheck;
    this.basePath = basePath;
  }
  peek() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[idx];
  }
  eat() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[this.idx++];
  }
  rewind() {
    this.idx--;
  }
  ignoreSpace() {
    while (this.peek() === " ") {
      this.eat();
    }
  }
  parseString() {
    this.ignoreSpace();
    if (this.peek() != "'") {
      return Err("Expected a rule starting with ', but found " + readable(this.peek()));
    }
    this.eat();
    const result = [];
    let ch;
    while (true) {
      ch = this.eat();
      switch (ch) {
        case "\\":
          switch (this.peek()) {
            case "'":
            case "\\":
            case "|":
              result.push(this.eat());
              break;
            case "n":
              this.eat();
              result.push("\n");
              break;
            default:
              result.push(ch);
              break;
          }
          break;
        case "'":
          return Ok(result.join(""));
        case "\n":
          return Err("Expected a rule ending with ', but found newline. Note: escape intentional newline with '\\n'");
        case EOF:
          return Err("Expected a rule ending with ', but found nothing");
        case "|":
          result.push(ANCHOR);
          break;
        default:
          result.push(ch);
          break;
      }
    }
  }
  parseMapArrow() {
    this.ignoreSpace();
    const first = this.eat(), second = this.eat();
    if (first === "-" && second === ">") {
      return Ok(0 /* Insert */);
    } else if (first === "-" && second === "x") {
      return Ok(1 /* Delete */);
    } else if (first === "-" && second === "f") {
      return Ok(2 /* Import */);
    }
    return Err(`Expected ->, -x or -f, but found ${readable(first)}${readable(second)}`);
  }
  parseComment() {
    this.ignoreSpace();
    let ch = this.peek();
    if (ch === "#") {
      while (ch != "\n" && ch != EOF) {
        ch = this.eat();
      }
      if (ch === "\n") {
        this.rewind();
      }
    }
    if (ch != "\n" && ch != EOF) {
      return Err("Expected only one rule in each line, but found " + readable(ch));
    }
    return Ok("#no content#");
  }
  isSideRule() {
    this.ignoreSpace();
    const ch = this.peek();
    if (ch != "+") {
      return false;
    } else {
      this.eat();
      return true;
    }
  }
  parseOne() {
    const r1 = this.parseString();
    if (!r1.isOk) {
      return Err(r1.error);
    }
    const r2 = this.parseMapArrow();
    if (!r2.isOk) {
      return Err(r2.error);
    }
    const r3 = this.parseString();
    if (!r3.isOk) {
      return Err(r3.error);
    }
    const rule = new Rule();
    if (this.isSideRule()) {
      if (r2.value === 1 /* Delete */) {
        return Err("Expected ->, but found -x. Note: selection rules cannot be deletion rules");
      }
      const rightInsert = this.parseString();
      if (!rightInsert.isOk) {
        return Err(rightInsert.error);
      }
      const sideRule = new SideRule(r1.value, r3.value, rightInsert.value);
      if (!sideRule.isValid) {
        return Err("Expected one char, but found multiple. Note: the selection rule trigger char can only be a single character");
      }
      rule.type = 1 /* SideRule */;
      rule.side = sideRule;
    } else {
      let leftPart = r1.value;
      let rightPart = r3.value;
      let arrowType = r2.value;
      if (r2.value === 2 /* Import */) {
        const path = (0, import_path.join)(this.basePath, r3.value);
        if (r3.value === "" || !(0, import_fs.existsSync)(path) || !(0, import_fs.statSync)(path).isFile()) {
          return Err(`File not found: "${r3.value}"`);
        }
        if (this.justCheck) {
          rightPart = ANCHOR;
        } else {
          const content2 = (0, import_fs.readFileSync)(path, "utf-8");
          rightPart = content2 + ANCHOR;
        }
        arrowType = 0 /* Insert */;
      }
      const convRule = new ConvRule(leftPart, rightPart, arrowType === 1 /* Delete */);
      if (!convRule.isValid) {
        return Err(convRule.invalidReasons());
      }
      rule.type = 0 /* ConvRule */;
      rule.conv = convRule;
    }
    const r4 = this.parseComment();
    if (!r4.isOk) {
      return Err(r4.error);
    }
    return Ok(rule);
  }
  parse() {
    let line = 1;
    while (true) {
      const r = this.parseComment();
      if (!r.isOk) {
        const rRes = this.parseOne();
        if (!rRes.isOk) {
          for (const msg of rRes.error.split("\n")) {
            this.errors.push(`line ${line}: ` + msg);
          }
        } else if (rRes.value.type === 0 /* ConvRule */) {
          this.convRules.push(rRes.value.conv);
        } else {
          const s = rRes.value.side;
          this.sideRules.set(s.trig, { l: s.left, r: s.right });
        }
      }
      const ch = this.eat();
      if (ch === "\n") {
        line++;
      } else {
        break;
      }
    }
  }
};
var Rules = class {
  constructor(ruletxt, justCheck = false, basePath = "") {
    const parser2 = new RuleParser(ruletxt, justCheck, basePath);
    parser2.parse();
    this.rules = [];
    this.insertTrigSet = /* @__PURE__ */ new Set();
    this.deleteTrigSet = /* @__PURE__ */ new Set();
    this.lmax = this.rmax = 0;
    this.errors = parser2.errors;
    if (this.errors.length > 0)
      return;
    if (justCheck)
      return;
    this.rules = parser2.convRules;
    this.index = newConvRulesIndex(this.rules);
    this.sideInsertMap = parser2.sideRules;
    for (const r of this.rules) {
      if (r.isForDelete) {
        this.deleteTrigSet.add(r.trigHintChar);
      } else {
        this.insertTrigSet.add(r.trigHintChar);
      }
      if (r.lBefore2AnchorLen > this.lmax)
        this.lmax = r.lBefore2AnchorLen;
      if (r.lAfterAnchorLen > this.rmax)
        this.rmax = r.lAfterAnchorLen;
    }
  }
  match(input, insChar, insPosBaseLineHead) {
    const leftMatch = Array.from(input.slice(0, insPosBaseLineHead));
    leftMatch.push(insChar);
    const candidates = this.index.collectIdxsAlong(leftMatch);
    for (const idx of candidates.sort((a, b) => a - b)) {
      if (this.rules[idx].canConvert(input, insChar, insPosBaseLineHead)) {
        return this.rules[idx];
      }
    }
    return null;
  }
};
function newConvRulesIndex(rules) {
  const root = new TrieNode();
  for (let i = 0; i < rules.length; i++) {
    root.insert(rules[i], i);
  }
  return root;
}
var TrieNode = class {
  constructor() {
    this.next = /* @__PURE__ */ new Map();
    this.value = [];
  }
  isKeyStop() {
    return this.value.length > 0;
  }
  insert(rule, idx) {
    const key = rule.leftMatchPart();
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      const ch = key[i];
      if (node.next.has(ch)) {
        node = node.next.get(ch);
      } else {
        const newNode = new TrieNode();
        node.next.set(ch, newNode);
        node = newNode;
      }
    }
    node.value.push(idx);
  }
  collectIdxsAlong(key) {
    const idxs = [];
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      if (node.isKeyStop()) {
        idxs.push(...node.value);
      }
      node = node.next.get(key[i]);
      if (node === void 0) {
        break;
      }
    }
    if (node != void 0 && node.isKeyStop()) {
      idxs.push(...node.value);
    }
    return idxs;
  }
};

// src/ext_libertyzone.ts
var import_view = require("@codemirror/view");
function libertyZone(zonespotter) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(_) {
      this.decorations = import_view.Decoration.none;
      this.cleanTimer = -1;
    }
    get isTimerActive() {
      return this.cleanTimer >= 0;
    }
    tryRemoveTimer() {
      if (this.isTimerActive) {
        window.clearTimeout(this.cleanTimer);
        this.cleanTimer = -1;
      }
    }
    update(update) {
      const range = zonespotter(update);
      if (range === void 0 || update.state.doc.lineAt(range.from).from == range.from) {
        this.tryRemoveTimer();
        this.cleanTimer = window.setTimeout(() => {
          if (this.decorations.size) {
            this.decorations = import_view.Decoration.none;
          }
        }, 1e3);
        return;
      }
      this.decorations = import_view.Decoration.set(import_view.Decoration.widget({
        widget: new MarkWidget(15),
        side: 1
      }).range(range.from));
      this.tryRemoveTimer();
    }
  }, {
    decorations: (v) => v.decorations
  });
}
var MarkWidget = class extends import_view.WidgetType {
  constructor(lineHeight) {
    super();
    this.lineHeight = lineHeight;
  }
  toDOM() {
    const mark = document.createElement("span");
    mark.style.position = "relative";
    mark.style.top = `-${this.lineHeight}px`;
    mark.innerText = "\u2B50\uFE0F";
    const wrapper = document.createElement("div");
    wrapper.style.display = "inline-block";
    wrapper.style.position = "absolute";
    wrapper.append(mark);
    return wrapper;
  }
  ignoreEvent() {
    return false;
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_language2 = require("@codemirror/language");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++)
      if (types[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class {
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur.type.is(before);
      if (!cur.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  get name() {
    return this.type.name;
  }
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache2; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let { id: id2, start, end, size } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var NodeWeakMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  set(node, value) {
    if (node instanceof BufferNode)
      this.setBuffer(node.context.buffer, node.index, value);
    else if (node instanceof TreeNode)
      this.map.set(node.tree, value);
  }
  get(node) {
    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
  }
  cursorSet(cursor, value) {
    if (cursor.buffer)
      this.setBuffer(cursor.buffer.buffer, cursor.index, value);
    else
      this.map.set(cursor.tree, value);
  }
  cursorGet(cursor) {
    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
  }
};
var Parser = class {
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    var _a;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072))
          ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan:
    for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1] || 65536;
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
      if (newStacks.length > 12)
        newStacks.splice(12, newStacks.length - 12);
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    return !!this.allActions(state, (a) => a == action ? true : null);
  }
  allActions(state, action) {
    let deflt = this.stateSlot(state, 4);
    let result = deflt ? action(deflt) : void 0;
    for (let i = this.stateSlot(state, 1); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  configure(config3) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config3.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(name2, set, base, modified) {
    this.name = name2;
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base.name, set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base.set)
      if (!parent.modified.length)
        for (let config3 of configs)
          set.push(Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule2(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule2 = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule2.empty = new Rule2([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  comment,
  lineComment: t(comment),
  blockComment: t(comment),
  docComment: t(comment),
  name,
  variableName: t(name),
  typeName,
  tagName: t(typeName),
  propertyName,
  attributeName: t(propertyName),
  className: t(name),
  labelName: t(name),
  namespace: t(name),
  macroName: t(name),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number,
  integer: t(number),
  float: t(number),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier("definition"),
  constant: Tag.defineModifier("constant"),
  function: Tag.defineModifier("function"),
  standard: Tag.defineModifier("standard"),
  local: Tag.defineModifier("local"),
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@lezer/python/dist/index.js
var printKeyword = 1;
var indent = 194;
var dedent = 195;
var newline$1 = 196;
var blankLineStart = 197;
var newlineBracketed = 198;
var eof = 199;
var stringContent = 200;
var Escape = 2;
var replacementStart = 3;
var stringEnd = 201;
var ParenL = 24;
var ParenthesizedExpression = 25;
var TupleExpression = 49;
var ComprehensionExpression = 50;
var BracketL = 55;
var ArrayExpression = 56;
var ArrayComprehensionExpression = 57;
var BraceL = 59;
var DictionaryExpression = 60;
var DictionaryComprehensionExpression = 61;
var SetExpression = 62;
var SetComprehensionExpression = 63;
var ArgList = 65;
var subscript = 238;
var String$1 = 71;
var stringStart = 241;
var stringStartD = 242;
var stringStartL = 243;
var stringStartLD = 244;
var stringStartR = 245;
var stringStartRD = 246;
var stringStartRL = 247;
var stringStartRLD = 248;
var FormatString = 72;
var stringStartF = 249;
var stringStartFD = 250;
var stringStartFL = 251;
var stringStartFLD = 252;
var stringStartFR = 253;
var stringStartFRD = 254;
var stringStartFRL = 255;
var stringStartFRLD = 256;
var FormatReplacement = 73;
var nestedFormatReplacement = 77;
var importList = 263;
var TypeParamList = 112;
var ParamList = 130;
var SequencePattern = 151;
var MappingPattern = 152;
var PatternArgList = 155;
var newline = 10;
var carriageReturn = 13;
var space = 32;
var tab = 9;
var hash = 35;
var parenOpen = 40;
var dot = 46;
var braceOpen = 123;
var braceClose = 125;
var singleQuote = 39;
var doubleQuote = 34;
var backslash = 92;
var letter_o = 111;
var letter_x = 120;
var letter_N = 78;
var letter_u = 117;
var letter_U = 85;
var bracketed = /* @__PURE__ */ new Set([
  ParenthesizedExpression,
  TupleExpression,
  ComprehensionExpression,
  importList,
  ArgList,
  ParamList,
  ArrayExpression,
  ArrayComprehensionExpression,
  subscript,
  SetExpression,
  SetComprehensionExpression,
  FormatString,
  FormatReplacement,
  nestedFormatReplacement,
  DictionaryExpression,
  DictionaryComprehensionExpression,
  SequencePattern,
  MappingPattern,
  PatternArgList,
  TypeParamList
]);
function isLineBreak(ch) {
  return ch == newline || ch == carriageReturn;
}
function isHex(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
var newlines = new ExternalTokenizer((input, stack) => {
  let prev;
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (stack.context.flags & cx_Bracketed) {
    if (isLineBreak(input.next))
      input.acceptToken(newlineBracketed, 1);
  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {
    let spaces = 0;
    while (input.next == space || input.next == tab) {
      input.advance();
      spaces++;
    }
    if (input.next == newline || input.next == carriageReturn || input.next == hash)
      input.acceptToken(blankLineStart, -spaces);
  } else if (isLineBreak(input.next)) {
    input.acceptToken(newline$1, 1);
  }
}, { contextual: true });
var indentation = new ExternalTokenizer((input, stack) => {
  let context = stack.context;
  if (context.flags)
    return;
  let prev = input.peek(-1);
  if (prev == newline || prev == carriageReturn) {
    let depth = 0, chars = 0;
    for (; ; ) {
      if (input.next == space)
        depth++;
      else if (input.next == tab)
        depth += 8 - depth % 8;
      else
        break;
      input.advance();
      chars++;
    }
    if (depth != context.indent && input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < context.indent)
        input.acceptToken(dedent, -chars);
      else
        input.acceptToken(indent);
    }
  }
});
var cx_Bracketed = 1;
var cx_String = 2;
var cx_DoubleQuote = 4;
var cx_Long = 8;
var cx_Raw = 16;
var cx_Format = 32;
function Context(parent, indent2, flags) {
  this.parent = parent;
  this.indent = indent2;
  this.flags = flags;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent2 + (indent2 << 4) + flags + (flags << 6);
}
var topIndent = new Context(null, 0, 0);
function countIndent(space2) {
  let depth = 0;
  for (let i = 0; i < space2.length; i++)
    depth += space2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
var stringFlags = new Map([
  [stringStart, 0],
  [stringStartD, cx_DoubleQuote],
  [stringStartL, cx_Long],
  [stringStartLD, cx_Long | cx_DoubleQuote],
  [stringStartR, cx_Raw],
  [stringStartRD, cx_Raw | cx_DoubleQuote],
  [stringStartRL, cx_Raw | cx_Long],
  [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote],
  [stringStartF, cx_Format],
  [stringStartFD, cx_Format | cx_DoubleQuote],
  [stringStartFL, cx_Format | cx_Long],
  [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote],
  [stringStartFR, cx_Format | cx_Raw],
  [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote],
  [stringStartFRL, cx_Format | cx_Raw | cx_Long],
  [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]
].map(([term, flags]) => [term, flags | cx_String]));
var trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term, _, input) {
    if (context.flags & cx_Bracketed && bracketed.has(term) || (term == String$1 || term == FormatString) && context.flags & cx_String)
      return context.parent;
    return context;
  },
  shift(context, term, stack, input) {
    if (term == indent)
      return new Context(context, countIndent(input.read(input.pos, stack.pos)), 0);
    if (term == dedent)
      return context.parent;
    if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart)
      return new Context(context, 0, cx_Bracketed);
    if (stringFlags.has(term))
      return new Context(context, 0, stringFlags.get(term) | context.flags & cx_Bracketed);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
var legacyPrint = new ExternalTokenizer((input) => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i))
      return;
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next)))
    return;
  for (let off = 0; ; off++) {
    let next = input.peek(off);
    if (next == space || next == tab)
      continue;
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return;
  }
});
var strings = new ExternalTokenizer((input, stack) => {
  let { flags } = stack.context;
  let quote = flags & cx_DoubleQuote ? doubleQuote : singleQuote;
  let long = (flags & cx_Long) > 0;
  let escapes = !(flags & cx_Raw);
  let format = (flags & cx_Format) > 0;
  let start = input.pos;
  for (; ; ) {
    if (input.next < 0) {
      break;
    } else if (format && input.next == braceOpen) {
      if (input.peek(1) == braceOpen) {
        input.advance(2);
      } else {
        if (input.pos == start) {
          input.acceptToken(replacementStart, 1);
          return;
        }
        break;
      }
    } else if (escapes && input.next == backslash) {
      if (input.pos == start) {
        input.advance();
        let escaped = input.next;
        if (escaped >= 0) {
          input.advance();
          skipEscape(input, escaped);
        }
        input.acceptToken(Escape);
        return;
      }
      break;
    } else if (input.next == quote && (!long || input.peek(1) == quote && input.peek(2) == quote)) {
      if (input.pos == start) {
        input.acceptToken(stringEnd, long ? 3 : 1);
        return;
      }
      break;
    } else if (input.next == newline) {
      if (long) {
        input.advance();
      } else if (input.pos == start) {
        input.acceptToken(stringEnd);
        return;
      }
      break;
    } else {
      input.advance();
    }
  }
  if (input.pos > start)
    input.acceptToken(stringContent);
});
function skipEscape(input, ch) {
  if (ch == letter_o) {
    for (let i = 0; i < 2 && input.next >= 48 && input.next <= 55; i++)
      input.advance();
  } else if (ch == letter_x) {
    for (let i = 0; i < 2 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_u) {
    for (let i = 0; i < 4 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_U) {
    for (let i = 0; i < 8 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_N) {
    if (input.next == braceOpen) {
      input.advance();
      while (input.next >= 0 && input.next != braceClose && input.next != singleQuote && input.next != doubleQuote && input.next != newline)
        input.advance();
      if (input.next == braceClose)
        input.advance();
    }
  }
}
var pythonHighlighting = styleTags({
  'async "*" "**" FormatConversion FormatSpec': tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": tags.controlKeyword,
  "in not and or is del": tags.operatorKeyword,
  "from def class global nonlocal lambda": tags.definitionKeyword,
  import: tags.moduleKeyword,
  "with as print": tags.keyword,
  Boolean: tags.bool,
  None: tags.null,
  VariableName: tags.variableName,
  "CallExpression/VariableName": tags.function(tags.variableName),
  "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
  "ClassDefinition/VariableName": tags.definition(tags.className),
  PropertyName: tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  Comment: tags.lineComment,
  Number: tags.number,
  String: tags.string,
  FormatString: tags.special(tags.string),
  Escape: tags.escape,
  UpdateOp: tags.updateOperator,
  "ArithOp!": tags.arithmeticOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  AssignOp: tags.definitionOperator,
  Ellipsis: tags.punctuation,
  At: tags.meta,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator
});
var spec_identifier = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 };
var parser = LRParser.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rOOQS,5>r,5>rO#KrQdO,5>qO#LTQdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#L]QdO1G1dOOQS7+)T7+)TP#LbQdO'#FwO#LrQdO1G2OO#MVQdO1G2OO#MgQdO1G2OP#MrQdO'#FxO#NPQdO7+)VO#NaQdO7+)VO#NaQdO7+)VO#NiQdO7+)VO#NyQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ dQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$ tQtO1G1|P$!OQdO'#FvOOQS1G2R1G2RP$!]QdO'#F{O$!jQdO7+)jO$#TQdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#cQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$#|QdO<<M[OOQS,5<q,5<qO$$_QdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$mQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(hQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$(uQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)WQfO7+'OO$)cQdO'#F_O$*jQdO7+'jO$*zQdO7+'jOOQS7+'j7+'jO$+VQdO<<LqO$+gQdO<<LqO$+gQdO<<LqO$+oQdO'#H^OOQS<<Lh<<LhO$+yQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,dQdO1G4RO$,lQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$,wQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-kQtO'#FaOOQS'#Fc'#FcO$-{QdO'#FbO$.mQdO'#FbOOQS'#Fb'#FbO$.rQdO'#IYO$)cQdO'#FiO$)cQdO'#FiO$/ZQdO'#FjO$)cQdO'#FkO$/bQdO'#IZOOQS'#IZ'#IZO$0PQdO,5;yOOQS<<KU<<KUO$0XQdO<<KUO$0iQdOANB]O$0yQdOANB]O$1RQdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1lQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2TQdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2]QtO,5<SO$)cQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$2}QdO,5;|O$3SQdO,5;|OOQS'#Fg'#FgO$)cQdO'#G`O$3tQdO,5<QO$4`QdO,5>tO$4pQdO,5>tO1XQdO,5<PO$5RQdO,5<TO$5WQdO,5<TO$)cQdO'#I[O$5]QdO'#I[O$5bQdO,5<UOOQS,5<V,5<VO'vQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5gQdOG27wO$5wQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$5|QtO'#FaO$6TQdO'#I]O$6cQdO'#I]O$6kQdO,5<XOOQS1G1h1G1hO$6pQdO1G1hO$6uQdO,5<zOOQS-E:^-E:^O$7aQdO,5=OO$7xQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8YQdO,5>vO$)cQdO,5>vOOQS1G1p1G1pO$8hQtO,5<[OOQU7+'P7+'PO$+oQdO1G/iO$)cQdO,5<YO$8oQdO,5>wO$8vQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)cQdO'#GdO$9OQdO1G4bO$9YQdO1G4bO$9bQdO1G4bOOQS7+%T7+%TO$9pQdO1G1tO$:OQtO'#FaO$:VQdO,5<}OOQS,5<},5<}O$:eQdO1G4cOOQS-E:a-E:aO$)cQdO,5<|O$:lQdO,5<|O$:qQdO7+)|OOQS-E:`-E:`O$:{QdO7+)|O$)cQdO,5<ZP$)cQdO'#GcO$;TQdO1G2hO$)cQdO1G2hP$;cQdO'#GbO$;jQdO<<MhO$;tQdO1G1uO$<SQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<bQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<uQdO'#GOO'vQdO'#GtO$=SQdO,59bO$=XQdO,59bO$=`QdO,59mO$=eQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>O~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-VO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)oOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)cOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-VOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)cOz/zO#[/OO%j.yO!['Oa~O{$da~P%SOg'Pa~P$)cOz0SOg'Pa~Oa0UO!['Oi~P$)oOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-VO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)cO{0^O~Oa0UO!['Oq~P$)oOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)oOa0UO!['Oy~P$)oO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=l'QPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=xPP={>m>pPP'Z'ZPP?PPP'Z'ZPP'Z'Z'Z'Z'Z?T?}'ZP@QP@WD_G{HPPHSH^Hb'ZPPPHeHn'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHtIQIYPIaIgPIaPIaIaPPPIaPKuPLOLYL`KuPIaLiPIaPLpLvPLzM`M}NhLzLzNnN{LzLzLzLz! a! g! j! o! r! |!!S!!`!!r!!x!#S!#Y!#v!#|!$S!$^!$d!$j!$|!%W!%^!%d!%n!%t!%z!&Q!&W!&^!&h!&n!&x!'O!'X!'_!'n!'v!(Q!(XPPPPPPPPPPP!(_!(b!(h!(q!({!)WPPPPPPPPPPPP!-z!/`!3`!6pPP!6x!7X!7b!8Z!8Q!8d!8j!8m!8p!8s!8{!9lPPPPPPPPPPPPPPPPP!9o!9s!9yP!:_!:c!:o!:x!;U!;l!;o!;r!;x!<O!<U!<XP!<a!<j!=f!=i]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r}!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!P!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!R!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!T!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!V!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!X!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!]!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&cVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0r%mXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s![!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aR,^*RX#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&bQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QQ/q/VR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uR.S-fhUOn#d#g$j%|&_'w(p(r)t,P%S!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!]!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "\u26A0 print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: trackIndent,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],
  topRules: { "Script": [0, 5] },
  specialized: [{ term: 221, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 7664
});

// node_modules/@codemirror/lang-python/dist/index.js
var import_language = require("@codemirror/language");
var import_autocomplete = require("@codemirror/autocomplete");
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function defID(type) {
  return (node, def, outer) => {
    if (outer)
      return false;
    let id2 = node.node.getChild("VariableName");
    if (id2)
      def(id2, type);
    return true;
  };
}
var gatherCompletions = {
  FunctionDefinition: /* @__PURE__ */ defID("function"),
  ClassDefinition: /* @__PURE__ */ defID("class"),
  ForStatement(node, def, outer) {
    if (outer)
      for (let child = node.node.firstChild; child; child = child.nextSibling) {
        if (child.name == "VariableName")
          def(child, "variable");
        else if (child.name == "in")
          break;
      }
  },
  ImportStatement(_node, def) {
    var _a, _b;
    let { node } = _node;
    let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "from";
    for (let ch = node.getChild("import"); ch; ch = ch.nextSibling) {
      if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as")
        def(ch, isFrom ? "variable" : "namespace");
    }
  },
  AssignStatement(node, def) {
    for (let child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName")
        def(child, "variable");
      else if (child.name == ":" || child.name == "AssignOp")
        break;
    }
  },
  ParamList(node, def) {
    for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name)))
        def(child, "variable");
      prev = child;
    }
  },
  CapturePattern: /* @__PURE__ */ defID("variable"),
  AsPattern: /* @__PURE__ */ defID("variable"),
  __proto__: null
};
function getScope(doc, node) {
  let cached = cache.get(node);
  if (cached)
    return cached;
  let completions = [], top = true;
  function def(node2, type) {
    let name2 = doc.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (node2.name) {
      let gather = gatherCompletions[node2.name];
      if (gather && gather(node2, def, top) || !top && ScopeNodes.has(node2.name))
        return false;
      top = false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache.set(node, completions);
  return completions;
}
var Identifier = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var dontComplete = ["String", "FormatString", "Comment", "PropertyName"];
function localCompletionSource(context) {
  let inner = (0, import_language.syntaxTree)(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
var globals = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((n) => ({ label: n, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((n) => ({ label: n, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((n) => ({ label: n, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((n) => ({ label: n, type: "function" })));
var snippets = [
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	\n", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
];
var globalCompletion = /* @__PURE__ */ (0, import_autocomplete.ifNotIn)(dontComplete, /* @__PURE__ */ (0, import_autocomplete.completeFromList)(/* @__PURE__ */ globals.concat(snippets)));
function innerBody(context) {
  let { node, pos } = context;
  let lineIndent = context.lineIndent(pos, -1);
  let found = null;
  for (; ; ) {
    let before = node.childBefore(pos);
    if (!before) {
      break;
    } else if (before.name == "Comment") {
      pos = before.from;
    } else if (before.name == "Body" || before.name == "MatchBody") {
      if (context.baseIndentFor(before) + context.unit <= lineIndent)
        found = before;
      node = before;
    } else if (before.name == "MatchClause") {
      node = before;
    } else if (before.type.is("Statement")) {
      node = before;
    } else {
      break;
    }
  }
  return found;
}
function indentBody(context, node) {
  let base = context.baseIndentFor(node);
  let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
  if (/^\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
    return null;
  if (/^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
    return null;
  return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  name: "python",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        Body: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        MatchBody: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        TryStatement: (cx) => /^\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        MatchStatement: (cx) => {
          if (/^\s*case /.test(cx.textAfter))
            return cx.baseIndent + cx.unit;
          return cx.continue();
        },
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "]" }),
        "String FormatString": () => null,
        Script: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = inner && indentBody(context, inner)) !== null && _a !== void 0 ? _a : context.continue();
        }
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": import_language.foldInside,
        Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function python() {
  return new import_language.LanguageSupport(pythonLanguage, [
    pythonLanguage.data.of({ autocomplete: localCompletionSource }),
    pythonLanguage.data.of({ autocomplete: globalCompletion })
  ]);
}

// src/settings.ts
var config2 = {
  name: "obsidian",
  dark: false,
  background: "var(--background-primary)",
  foreground: "var(--text-normal)",
  selection: "var(--text-selection)",
  cursor: "var(--text-normal)",
  activeLine: "var(--background-primary)",
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)"
};
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)], color: config2.string },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: config2.constant },
  { tag: tags.comment, color: config2.comment },
  { tag: tags.invalid, color: config2.invalid }
]);
var obsidianTheme = import_view2.EditorView.theme({
  "&": {
    color: config2.foreground,
    backgroundColor: config2.background
  },
  ".cm-content": { caretColor: config2.cursor },
  "&.cm-focused .cm-cursor": { borderLeftColor: config2.cursor },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, & ::selection": { backgroundColor: config2.selection },
  ".cm-activeLine": { backgroundColor: config2.activeLine },
  ".cm-activeLineGutter": { backgroundColor: config2.background },
  ".cm-selectionMatch": { backgroundColor: config2.selection },
  ".cm-gutters": {
    backgroundColor: config2.background,
    color: config2.comment,
    borderRight: "1px solid var(--background-modifier-border)"
  },
  ".cm-lineNumbers, .cm-gutterElement": { color: "inherit" }
});
var BaseProfileName = "global";
var ProfileSwitch = import_state.Annotation.define();
var DEFAULT_SETTINGS = {
  debug: false,
  convertRules: DEFAULT_RULES,
  zoneIndicatorOn: false,
  autoFormatOn: true,
  profiles: [
    { title: BaseProfileName, content: DEFAULT_RULES }
  ],
  activeProfile: BaseProfileName
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.editorState = {
      selectedProfileName: BaseProfileName,
      selectedProfileEl: void 0,
      baseProfileEl: void 0,
      profilesMap: new Map(plugin.settings.profiles.map((p) => {
        return [p.title, p.content];
      })),
      editedProfile: /* @__PURE__ */ new Set()
    };
  }
  hide() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.ruleEditor) == null ? void 0 : _a.destroy();
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = this.editorState;
      if (set.size > 0) {
        const newProfiles = [];
        for (const [key, value] of map) {
          newProfiles.push({ title: key, content: value });
        }
        this.plugin.settings.profiles = newProfiles;
        log("setting: save profiles");
        yield this.plugin.saveSettings();
      }
      const activeProfile = this.plugin.settings.activeProfile;
      if (target != activeProfile || set.has(BaseProfileName) || set.has(activeProfile)) {
        const newRule = target === BaseProfileName ? map.get(BaseProfileName) : map.get(BaseProfileName) + "\n" + map.get(target);
        yield this.plugin.configureProfile(target, newRule);
      }
    });
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Typing Transformer Settings" });
    new import_obsidian.Setting(containerEl).setName("Debug Log").setDesc("Enable debug log to console.").addToggle(
      (comp) => comp.setValue(plugin.settings.debug).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleDebugLog();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Auto Format").setDesc("Enable the auto insertion of spaces.").addToggle(
      (comp) => comp.setValue(plugin.settings.autoFormatOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleAutoFormat();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Zone Indicator").setDesc("Enable indication of a zone's start point with '\u2B50\uFE0F'").addToggle(
      (comp) => comp.setValue(plugin.settings.zoneIndicatorOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleIndicator();
      }))
    );
    this.ruleEditor = createRuleEditorInContainer(containerEl, plugin, this.editorState);
  }
};
function createRuleEditorInContainer(container, plugin, state) {
  const fragment = document.createDocumentFragment();
  fragment.createEl("span", { text: "Enter conversion, selection, and deletion rules here. NOTES:" });
  const ol = fragment.createEl("ol");
  ol.createEl("li", { text: "Each line is one rule. Rules that come first have higher priority." });
  ol.createEl("li", { text: 'Lines starting with "#" are treated as comments and ignored. Inline comments are also allowed' });
  ol.createEl("li", { text: "Certain characters ' | \\ must be escaped with backslashes \\." });
  ol.createEl("li", { text: "Whatever tab you are on when the plugin settings tab quits will be the profile that is chosen" });
  ol.createEl("li", { text: "The 'global' profile will always be active" });
  const convertRulesSetting = new import_obsidian.Setting(container).setName("Rules").setDesc(fragment).setClass("rules-text-area");
  const profilesContainer = convertRulesSetting.controlEl.createDiv("rules-profiles");
  const customCSSWrapper = convertRulesSetting.controlEl.createDiv("rules-editor-wrapper");
  const rulesFooter = convertRulesSetting.controlEl.createDiv("rules-footer");
  const validity = rulesFooter.createDiv("rules-editor-validity");
  const validityIndicator = new import_obsidian.ExtraButtonComponent(validity);
  validityIndicator.setIcon("checkmark").extraSettingsEl.addClass("rules-editor-validity-indicator");
  const validityText = validity.createDiv("rules-editor-validity-text");
  validityText.classList.add("setting-item-description", "rules-editor-validity-txt");
  function resetValidityIndicator() {
    validityIndicator.setIcon("");
    validityIndicator.extraSettingsEl.removeClasses(["invalid", "valid"]);
    validityText.setText("");
  }
  function tryResetValidityIndicator() {
    return __async(this, null, function* () {
      if (validityIndicator.extraSettingsEl.hasClass("invalid")) {
        return new Promise((resolve, _reject) => {
          new ConfirmationModal(
            app,
            "Are you sure you want to discard changes?",
            (ans) => __async(this, null, function* () {
              if (ans)
                resetValidityIndicator();
              resolve(ans);
            })
          ).open();
        });
      } else {
        resetValidityIndicator();
        return new Promise((resolve, _reject) => resolve(true));
      }
    });
  }
  function updateValidityIndicator(success, errs) {
    validityIndicator.setIcon(success ? "checkmark" : "cross");
    validityIndicator.extraSettingsEl.removeClass(success ? "invalid" : "valid");
    validityIndicator.extraSettingsEl.addClass(success ? "valid" : "invalid");
    const fragment2 = document.createDocumentFragment();
    for (const err of errs) {
      fragment2.createEl("div", { text: err });
    }
    validityText.setText(success ? "Saved" : fragment2);
  }
  const extensions = [
    obsidianTheme,
    (0, import_view2.lineNumbers)(),
    import_view2.EditorView.lineWrapping,
    python(),
    (0, import_language2.syntaxHighlighting)(obsidianHighlightStyle),
    import_view2.EditorView.updateListener.of((v) => __async(this, null, function* () {
      if (v.docChanged) {
        if (v.transactions.reduce((swtich, tr) => swtich || tr.annotation(ProfileSwitch), false)) {
          return;
        }
        const value = v.state.doc.toString();
        yield feedRules(value);
      }
    }))
  ];
  const feedRules = (newRule) => __async(this, null, function* () {
    const errs = plugin.checkRules(newRule);
    if (errs.length != 0) {
      updateValidityIndicator(false, errs);
    } else {
      updateValidityIndicator(true, []);
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = state;
      map.set(target, newRule);
      set.add(target);
    }
  });
  const setCMEditorContent = (text) => {
    convertRulesEditor.dispatch({
      changes: { from: 0, to: convertRulesEditor.state.doc.length, insert: text },
      annotations: ProfileSwitch.of(true)
    });
  };
  const convertRulesEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({ doc: plugin.settings.convertRules, extensions })
  });
  customCSSWrapper.appendChild(convertRulesEditor.dom);
  const buttonsDiv = rulesFooter.createDiv("rules-editor-buttons");
  const reset = new import_obsidian.ButtonComponent(buttonsDiv);
  reset.setIcon("switch").setTooltip("Reset to default rules").onClick(() => __async(this, null, function* () {
    convertRulesEditor.setState(import_state.EditorState.create({ doc: DEFAULT_RULES, extensions }));
    yield feedRules(DEFAULT_RULES);
  }));
  const onProfileClick = (name2, el) => __async(this, null, function* () {
    var _a;
    if (!(yield tryResetValidityIndicator()))
      return;
    (_a = state.selectedProfileEl) == null ? void 0 : _a.removeClass("selected");
    el == null ? void 0 : el.addClass("selected");
    state.selectedProfileEl = el;
    state.selectedProfileName = name2;
    setCMEditorContent(state.profilesMap.get(name2));
  });
  const onRemoveProfileClick = (name2, el) => {
    if (el === state.selectedProfileEl)
      onProfileClick(BaseProfileName, state.baseProfileEl);
    state.profilesMap.delete(name2);
    state.editedProfile.add(name2);
    profilesContainer.removeChild(el);
  };
  const addProfile = (profile, selected) => {
    const button = new import_obsidian.ExtraButtonComponent(profilesContainer);
    const el = button.extraSettingsEl;
    el.accessKey = profile.title;
    button.onClick(() => onProfileClick(profile.title, el));
    el.addClass("rules-profile-button");
    el.setText(profile.title);
    if (profile.title != BaseProfileName) {
      const closeEl = new import_obsidian.ExtraButtonComponent(el).setIcon("cross").extraSettingsEl;
      closeEl.onClickEvent((ev) => {
        ev.stopPropagation();
        onRemoveProfileClick(profile.title, el);
      });
      closeEl.addClass("rules-profile-close");
    } else {
      state.baseProfileEl = el;
    }
    if (selected) {
      onProfileClick(profile.title, el);
    }
  };
  for (const profile of plugin.settings.profiles) {
    addProfile(profile, profile.title === plugin.settings.activeProfile);
  }
  const addButton = new import_obsidian.ExtraButtonComponent(profilesContainer).onClick(() => {
    if (state.profilesMap.size > 5) {
      new import_obsidian.Notice("You can only have 6 profiles at most.");
      return;
    }
    new StringInputModal(app, (value) => {
      if (state.profilesMap.has(value))
        return false;
      if (value === void 0)
        return true;
      state.profilesMap.set(value, "");
      state.editedProfile.add(value);
      profilesContainer.removeChild(addButton.extraSettingsEl);
      addProfile({ title: value, content: "" }, true);
      profilesContainer.appendChild(addButton.extraSettingsEl);
      return true;
    }).open();
  });
  addButton.extraSettingsEl.addClass("rules-profile-button");
  addButton.extraSettingsEl.setText("+");
  return convertRulesEditor;
}
var StringInputModal = class extends import_obsidian.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.submitEnterCallback = (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.onSubmit = onSubmit;
  }
  submit() {
    if (this.onSubmit(this.result))
      this.close();
    else
      this.err.setText("Profile already exists!");
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Profile Name");
    const container = contentEl.createDiv();
    const textComponent = new import_obsidian.TextComponent(container);
    this.err = container.createEl("p");
    textComponent.inputEl.style.width = "100%";
    textComponent.onChange((value) => this.result = value).inputEl.addEventListener("keydown", this.submitEnterCallback);
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => this.submit()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app2, prompt, conformCb) {
    super(app2);
    this.contentEl.createEl("p", { text: prompt });
    new import_obsidian.Setting(this.contentEl).addButton(
      (button) => button.setButtonText("Conform").onClick(() => __async(this, null, function* () {
        yield conformCb(true);
        this.close();
      }))
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => __async(this, null, function* () {
        yield conformCb(false);
        this.close();
      }))
    );
  }
};

// src/global_commands.ts
var import_obsidian2 = require("obsidian");
function getAllCommands(plugin) {
  const format = {
    id: "typing-trans-toggle-format",
    name: "Toggle Auto Formatting",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleAutoFormat();
    })
  };
  const zone = {
    id: "typing-trans-toggle-zone-indicator",
    name: "Toggle Auto Formatting Zone Indicator",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleIndicator();
    })
  };
  const ret = [format, zone];
  const useProfileX = (i) => __async(this, null, function* () {
    const profs = plugin.settings.profiles;
    if (i >= profs.length) {
      new import_obsidian2.Notice(`Profile ${i} doesn't exist`);
      return;
    }
    const { title, content: content2 } = profs[i];
    if (plugin.settings.activeProfile === title)
      return;
    const newRule = title === BaseProfileName ? content2 : profs[0].content + "\n" + content2;
    plugin.configureProfile(title, newRule);
  });
  for (let i = 0; i < 6; i++) {
    const useProfileCommand = {
      id: "typing-trans-p" + i.toString(),
      name: "apply profile " + i.toString() + (i === 0 ? " (global)" : ""),
      editorCallback: (_e, _v) => __async(this, null, function* () {
        yield useProfileX(i);
      })
    };
    ret.push(useProfileCommand);
  }
  return ret;
}

// src/main.ts
var ProgramTxn = import_state2.Annotation.define();
var deubgExt = import_state2.StateField.define({
  create: (_state) => {
    return 0;
  },
  update: (value, tr) => {
    if (tr.docChanged) {
      tr.changes.iterChanges((a, b, c, d, insert) => {
        console.log(a, b, c, d, insert.sliceString(0));
      });
    }
    return value;
  }
});
function ignoreThisTr(tr) {
  return !tr.docChanged || tr.annotation(ProgramTxn) || tr.isUserEvent("redo") || tr.isUserEvent("undo");
}
var TypingTransformer = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.configureProfile = (title, ruleString) => __async(this, null, function* () {
      this.settings.activeProfile = title;
      this.settings.convertRules = ruleString;
      this.configureRules(ruleString);
      this.updateProfileStatus();
      yield this.saveSettings();
    });
    this.configureRules = (ruleString) => {
      this.rules = new Rules(ruleString, false, this.basePath);
    };
    this.checkRules = (ruleString) => {
      return new Rules(ruleString, true, this.basePath).errors;
    };
    this.configureActiveExtsFromSettings = () => {
      const activeIds = [1 /* Conversion */, 0 /* SideInsert */];
      const { debug, zoneIndicatorOn, autoFormatOn } = this.settings;
      debug ? activeIds.push(4 /* Debug */) : null;
      zoneIndicatorOn ? activeIds.push(2 /* ZoneIndicator */) : null;
      autoFormatOn ? activeIds.push(3 /* AutoFormat */) : null;
      this.activeExts.forEach((_ext, idx) => this.activeExts[idx] = []);
      activeIds.forEach((extid) => this.activeExts[extid] = this.availablExts[extid]);
      this.activeExts.push((0, import_commands.history)({
        joinToEvent: (tr, isAdjacent) => {
          return !tr.annotation(ProgramTxn) && isAdjacent;
        }
      }));
    };
    this.toggleAutoFormat = () => __async(this, null, function* () {
      this.settings.autoFormatOn = !this.settings.autoFormatOn;
      yield this.saveAndReloadPlugin();
    });
    this.toggleDebugLog = () => __async(this, null, function* () {
      this.settings.debug = !this.settings.debug;
      yield this.saveAndReloadPlugin();
    });
    this.toggleIndicator = () => __async(this, null, function* () {
      this.settings.zoneIndicatorOn = !this.settings.zoneIndicatorOn;
      yield this.saveAndReloadPlugin();
    });
    this.saveAndReloadPlugin = () => __async(this, null, function* () {
      yield this.saveSettings();
      this.configureActiveExtsFromSettings();
      this.app.workspace.updateOptions();
    });
    this.spotLibertyZone = ({ view, docChanged }) => {
      if (!docChanged) {
        return;
      }
      const state = view.state;
      const mainSel = state.selection.asSingle().main;
      if (mainSel.anchor != mainSel.head) {
        return;
      }
      const line = state.doc.lineAt(mainSel.anchor);
      const from = line.from;
      const to = mainSel.anchor;
      if (from == to) {
        return;
      }
      for (const pos of this.specialSections) {
        if (pos.start.line <= line.number - 1 && line.number - 1 <= pos.end.line) {
          return;
        }
      }
      const checkInBlock = (blocks2, offset) => {
        for (let i = blocks2.length - 2; i > -1; i -= 2) {
          if (blocks2[i] < offset && offset <= blocks2[i + 1]) {
            return { exist: true, from: blocks2[i], to: blocks2[i + 1] };
          }
        }
        return { exist: false, from: 0, to: 0 };
      };
      const blocks = getBlockRanges(line.text, to - from);
      const r = checkInBlock(blocks.emphasis, to - from);
      if (r.exist) {
        const txt2 = state.sliceDoc(from + r.from, from + r.to);
        let i;
        for (i = 0; txt2[i] == txt2[0] && i < r.to; i++) {
          log("format: skip emphasis head", i, txt2[i]);
        }
        return { from: from + r.from + i, to };
      }
      const spBlocks = blocks.special;
      if (checkInBlock(spBlocks, to - from).exist) {
        return;
      }
      const txt = state.sliceDoc(from, to);
      for (let i = txt.length - 2; i > 0; i--) {
        const ch = txt[i];
        if (ch != " " && PUNCTS.has(ch) && !checkInBlock(spBlocks, i).exist) {
          return { from: from + i, to };
        }
      }
      return { from, to };
    };
    this.addLiberty = (update) => {
      const range = this.spotLibertyZone(update);
      if (range === void 0 || !update.selectionSet) {
        return;
      }
      if (update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      const from = range.from, to = range.to;
      const toUpdate = update.view.state.doc.sliceString(from, to);
      if (PUNCTS.has(toUpdate.charAt(toUpdate.length - 1))) {
        const trimmed = toUpdate.trim();
        if (trimmed === "") {
          return;
        }
        const lspace = toUpdate.length - toUpdate.trimStart().length;
        const rspace = toUpdate.length - toUpdate.trimEnd().length;
        log(
          "foramt: trigger char: %s, toUpdate: %s, lspace: %d, rspace: %d",
          toUpdate.charAt(toUpdate.length - 1),
          toUpdate,
          lspace,
          rspace
        );
        const formatted = formatLine(trimmed);
        if (formatted === trimmed) {
          return;
        }
        update.view.dispatch({ changes: { from: from + lspace, to: to - rspace, insert: formatLine(trimmed) }, annotations: ProgramTxn.of(true) });
      }
    };
    this.convertFilter = (update) => {
      if (!update.docChanged || update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      let shouldHijack = true;
      const changes = [];
      const { insertTrigSet, deleteTrigSet, lmax, rmax } = this.rules;
      update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (!shouldHijack) {
          return;
        }
        let trigger;
        if (fromA === toA && fromB + 1 === toB) {
          trigger = inserted.sliceString(0);
          if (!insertTrigSet.has(trigger)) {
            shouldHijack = false;
          }
        } else if (fromA + 1 === toA && fromB === toB) {
          const delChar = update.startState.sliceDoc(fromA, toA);
          if (!deleteTrigSet.has(delChar)) {
            shouldHijack = false;
          }
          trigger = DEL_TRIG;
          fromA = toA;
          fromB += 1;
          toB = fromB + 1;
        } else {
          shouldHijack = false;
        }
        if (!shouldHijack) {
          return;
        }
        let leftIdx = fromB - lmax;
        let insertPosFromInputTextHead = lmax;
        if (leftIdx < 0) {
          leftIdx = 0;
          insertPosFromInputTextHead = fromB;
        }
        const input = update.startState.sliceDoc(leftIdx, fromB + rmax);
        const rule = this.rules.match(input, trigger, insertPosFromInputTextHead);
        if (rule != null) {
          log("hit covert rule: %s", rule.left.join(""));
          const change = rule.mapToChanges(fromB, trigger === DEL_TRIG);
          change.annotations = ProgramTxn.of(true);
          changes.push(change);
        } else {
          shouldHijack = false;
        }
      });
      if (shouldHijack) {
        update.view.dispatch(...changes);
      }
      return;
    };
    this.sidesInsertFilter = (update) => {
      if (!update.docChanged || update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      let shouldHijack = true;
      const changes = [];
      update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA == toA || toB != fromB + 1 || !this.rules.sideInsertMap.has(char)) {
          shouldHijack = false;
          return;
        }
        const insert = this.rules.sideInsertMap.get(char);
        const replaced = update.startState.sliceDoc(fromA, toA);
        changes.push({ changes: { from: fromB, to: toB, insert: insert.l + replaced + insert.r }, annotations: ProgramTxn.of(true) });
      });
      if (shouldHijack) {
        update.view.dispatch(...changes);
      }
    };
    this.updateProfileStatus = () => {
      this.profileStatus.setText(`Active Profile: ${this.settings.activeProfile}`);
    };
  }
  onload() {
    return __async(this, null, function* () {
      if (this.app.vault.adapter instanceof import_obsidian3.FileSystemAdapter) {
        this.basePath = this.app.vault.adapter.getBasePath();
      }
      console.log("loading typing transformer plugin");
      yield this.loadSettings();
      initLog(this.settings);
      yield charliberty_default(charliberty_bg_default);
      this.specialSections = [];
      this.activeExts = [];
      this.availablExts = [
        import_view3.EditorView.updateListener.of(this.sidesInsertFilter),
        import_view3.EditorView.updateListener.of(this.convertFilter),
        libertyZone(this.spotLibertyZone),
        import_view3.EditorView.updateListener.of(this.addLiberty),
        deubgExt
      ];
      this.availablExts.forEach((_, idx) => this.activeExts[idx] = []);
      this.configureRules(this.settings.convertRules);
      this.configureActiveExtsFromSettings();
      this.registerEditorExtension(this.activeExts);
      this.registerEvent(this.app.metadataCache.on("changed", (_f, _d, meta2) => {
        var _a;
        this.specialSections.length = 0;
        (_a = meta2.sections) == null ? void 0 : _a.forEach((sec) => {
          if (sec.type == "code" || sec.type == "match") {
            this.specialSections.push(sec.position);
          }
        });
      }));
      this.addSettingTab(new SettingTab(this.app, this));
      for (const cmd of getAllCommands(this)) {
        this.addCommand(cmd);
      }
      this.profileStatus = this.addStatusBarItem();
      this.updateProfileStatus();
    });
  }
  onunload() {
    console.log("unloading typing transformer plugin");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const data = yield this.loadData();
      let defaultSource = DEFAULT_SETTINGS;
      if (data && !data.hasOwnProperty("profiles") && data.convertRules != DEFAULT_SETTINGS.convertRules) {
        const cloned = structuredClone(DEFAULT_SETTINGS);
        cloned.profiles[0].content = data.convertRules;
        defaultSource = cloned;
      }
      this.settings = Object.assign({}, defaultSource, data);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};

/* nosourcemap */